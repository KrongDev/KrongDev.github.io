[
  {
    "id": "2025-10-07-figma-design",
    "slug": "2025-10-07-figma-design",
    "title": "Figma로 시작하는 UI 디자인",
    "date": "2025-10-07",
    "category": "design",
    "subcategory": "figma",
    "tags": [
      "Figma",
      "UI/UX",
      "디자인",
      "툴"
    ],
    "excerpt": "Figma를 처음 시작하는 개발자를 위한 가이드입니다. 기본 기능부터 협업 방법까지 알아봅니다.",
    "author": "Geon Lee",
    "content": "<h1>Figma로 시작하는 UI 디자인 🎨</h1>\n<p>개발자도 알아야 할 Figma 기본 사용법을 정리했습니다.</p>\n<h2>Figma란?</h2>\n<p>Figma는 <strong>웹 기반 UI/UX 디자인 툴</strong>입니다. </p>\n<h3>주요 장점</h3>\n<ul>\n<li>☁️ <strong>클라우드 기반</strong>: 설치 불필요, 어디서나 접근</li>\n<li>👥 <strong>실시간 협업</strong>: 여러 명이 동시에 작업 가능</li>\n<li>🔗 <strong>개발자 친화적</strong>: CSS, React 코드 자동 생성</li>\n<li>💰 <strong>무료 플랜</strong>: 개인 프로젝트는 무료!</li>\n</ul>\n<h2>기본 도구 익히기</h2>\n<h3>1. Frame (프레임)</h3>\n<p>웹/앱의 화면을 나타내는 캔버스입니다.</p>\n<pre><code>단축키:\n- F: Frame 생성\n- 우측 속성 패널에서 프리셋 선택 가능\n  (iPhone, Desktop, Tablet 등)\n</code></pre>\n<h3>2. Shape Tools (도형 도구)</h3>\n<p>기본 UI 요소를 만드는 도구들입니다.</p>\n<ul>\n<li><strong>Rectangle (R)</strong>: 사각형</li>\n<li><strong>Ellipse (O)</strong>: 원형</li>\n<li><strong>Line (L)</strong>: 선</li>\n<li><strong>Text (T)</strong>: 텍스트</li>\n</ul>\n<h3>3. Auto Layout</h3>\n<p>Flexbox처럼 동작하는 레이아웃 시스템입니다.</p>\n<pre><code>사용법:\n1. 요소들을 선택\n2. Shift + A\n3. 간격, 정렬, 패딩 조정\n</code></pre>\n<p>이것만 잘 써도 개발자처럼 레이아웃을 구성할 수 있습니다!</p>\n<h2>Components (컴포넌트)</h2>\n<p>재사용 가능한 UI 요소를 만들 수 있습니다.</p>\n<h3>컴포넌트 만들기</h3>\n<ol>\n<li>요소 선택</li>\n<li><code>Cmd/Ctrl + Alt + K</code></li>\n<li>컴포넌트 완성!</li>\n</ol>\n<h3>Variants (베리언트)</h3>\n<p>버튼의 다양한 상태를 하나로 관리할 수 있습니다.</p>\n<pre><code>예: Button 컴포넌트\n- Variant: default, hover, active, disabled\n- Size: small, medium, large\n</code></pre>\n<h2>색상 시스템</h2>\n<h3>Local Styles</h3>\n<p>프로젝트 전체에서 사용할 색상을 정의합니다.</p>\n<pre><code>예:\n- Primary: #3B82F6\n- Secondary: #8B5CF6\n- Gray-100: #F3F4F6\n- Gray-900: #111827\n</code></pre>\n<h3>색상 적용</h3>\n<ol>\n<li>Fill 선택</li>\n<li>스타일 아이콘 클릭</li>\n<li><ul>\n<li>버튼으로 새 스타일 생성</li>\n</ul>\n</li>\n</ol>\n<h2>개발자를 위한 팁</h2>\n<h3>1. Inspect 패널 활용</h3>\n<pre><code>우측 패널에서 CSS 코드를 바로 확인할 수 있습니다:\n- Width, Height\n- Padding, Margin\n- Border-radius\n- Color (HEX, RGB)\n</code></pre>\n<h3>2. Export 설정</h3>\n<p>이미지를 다양한 포맷으로 내보낼 수 있습니다.</p>\n<ul>\n<li>PNG, JPG, SVG, PDF</li>\n<li>1x, 2x, 3x (레티나 대응)</li>\n</ul>\n<h3>3. 플러그인 추천</h3>\n<p>개발자에게 유용한 플러그인들:</p>\n<ul>\n<li><strong>Iconify</strong>: 수천 개의 아이콘</li>\n<li><strong>Lorem Ipsum</strong>: 더미 텍스트 생성</li>\n<li><strong>Unsplash</strong>: 무료 이미지 삽입</li>\n<li><strong>Content Reel</strong>: 실제 데이터 채우기</li>\n</ul>\n<h2>협업 워크플로우</h2>\n<h3>1. 디자이너 → 개발자</h3>\n<pre><code>1. 디자이너가 Figma에서 디자인 완성\n2. 링크 공유 (View 권한)\n3. 개발자는 Inspect로 수치 확인\n4. 이미지 Export\n5. 코드 구현\n</code></pre>\n<h3>2. Dev Mode (개발 모드)</h3>\n<p>2023년부터 추가된 기능으로, 개발자를 위한 전용 모드입니다.</p>\n<ul>\n<li>CSS, iOS, Android 코드 자동 생성</li>\n<li>Component 변경 사항 추적</li>\n<li>측정 도구 강화</li>\n</ul>\n<h2>실전 예제: 버튼 컴포넌트</h2>\n<pre><code>1. Rectangle 생성 (160 x 48)\n2. Border-radius: 8px\n3. Fill: Primary 색상\n4. Text 추가 (16px, Semibold)\n5. Auto Layout 적용 (Padding: 12px 24px)\n6. Component로 변환\n7. Variants 추가:\n   - State: default, hover, active\n   - Size: sm, md, lg\n</code></pre>\n<p>이렇게 만든 컴포넌트는 React나 Vue에서 그대로 구현할 수 있습니다!</p>\n<h2>단축키 모음</h2>\n<table>\n<thead>\n<tr>\n<th>기능</th>\n<th>Mac</th>\n<th>Windows</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Frame</td>\n<td>F</td>\n<td>F</td>\n</tr>\n<tr>\n<td>Rectangle</td>\n<td>R</td>\n<td>R</td>\n</tr>\n<tr>\n<td>Text</td>\n<td>T</td>\n<td>T</td>\n</tr>\n<tr>\n<td>Component</td>\n<td>Cmd+Opt+K</td>\n<td>Ctrl+Alt+K</td>\n</tr>\n<tr>\n<td>Copy CSS</td>\n<td>Cmd+C</td>\n<td>Ctrl+C</td>\n</tr>\n<tr>\n<td>Zoom In</td>\n<td>Cmd++</td>\n<td>Ctrl++</td>\n</tr>\n<tr>\n<td>Zoom Out</td>\n<td>Cmd+-</td>\n<td>Ctrl+-</td>\n</tr>\n</tbody></table>\n<h2>결론</h2>\n<p>Figma는 개발자와 디자이너의 협업을 원활하게 만들어주는 도구입니다.<br>기본 기능만 익혀도 충분히 활용할 수 있으니, 한번 시도해보세요! 🚀</p>\n<p><strong>공식 문서</strong>: <a href=\"https://www.figma.com/resources/learn-design/\">figma.com/resources/learn-design</a></p>\n",
    "rawContent": "\n# Figma로 시작하는 UI 디자인 🎨\n\n개발자도 알아야 할 Figma 기본 사용법을 정리했습니다.\n\n## Figma란?\n\nFigma는 **웹 기반 UI/UX 디자인 툴**입니다. \n\n### 주요 장점\n\n- ☁️ **클라우드 기반**: 설치 불필요, 어디서나 접근\n- 👥 **실시간 협업**: 여러 명이 동시에 작업 가능\n- 🔗 **개발자 친화적**: CSS, React 코드 자동 생성\n- 💰 **무료 플랜**: 개인 프로젝트는 무료!\n\n## 기본 도구 익히기\n\n### 1. Frame (프레임)\n\n웹/앱의 화면을 나타내는 캔버스입니다.\n\n```\n단축키:\n- F: Frame 생성\n- 우측 속성 패널에서 프리셋 선택 가능\n  (iPhone, Desktop, Tablet 등)\n```\n\n### 2. Shape Tools (도형 도구)\n\n기본 UI 요소를 만드는 도구들입니다.\n\n- **Rectangle (R)**: 사각형\n- **Ellipse (O)**: 원형\n- **Line (L)**: 선\n- **Text (T)**: 텍스트\n\n### 3. Auto Layout\n\nFlexbox처럼 동작하는 레이아웃 시스템입니다.\n\n```\n사용법:\n1. 요소들을 선택\n2. Shift + A\n3. 간격, 정렬, 패딩 조정\n```\n\n이것만 잘 써도 개발자처럼 레이아웃을 구성할 수 있습니다!\n\n## Components (컴포넌트)\n\n재사용 가능한 UI 요소를 만들 수 있습니다.\n\n### 컴포넌트 만들기\n\n1. 요소 선택\n2. `Cmd/Ctrl + Alt + K`\n3. 컴포넌트 완성!\n\n### Variants (베리언트)\n\n버튼의 다양한 상태를 하나로 관리할 수 있습니다.\n\n```\n예: Button 컴포넌트\n- Variant: default, hover, active, disabled\n- Size: small, medium, large\n```\n\n## 색상 시스템\n\n### Local Styles\n\n프로젝트 전체에서 사용할 색상을 정의합니다.\n\n```\n예:\n- Primary: #3B82F6\n- Secondary: #8B5CF6\n- Gray-100: #F3F4F6\n- Gray-900: #111827\n```\n\n### 색상 적용\n\n1. Fill 선택\n2. 스타일 아이콘 클릭\n3. + 버튼으로 새 스타일 생성\n\n## 개발자를 위한 팁\n\n### 1. Inspect 패널 활용\n\n```\n우측 패널에서 CSS 코드를 바로 확인할 수 있습니다:\n- Width, Height\n- Padding, Margin\n- Border-radius\n- Color (HEX, RGB)\n```\n\n### 2. Export 설정\n\n이미지를 다양한 포맷으로 내보낼 수 있습니다.\n\n- PNG, JPG, SVG, PDF\n- 1x, 2x, 3x (레티나 대응)\n\n### 3. 플러그인 추천\n\n개발자에게 유용한 플러그인들:\n\n- **Iconify**: 수천 개의 아이콘\n- **Lorem Ipsum**: 더미 텍스트 생성\n- **Unsplash**: 무료 이미지 삽입\n- **Content Reel**: 실제 데이터 채우기\n\n## 협업 워크플로우\n\n### 1. 디자이너 → 개발자\n\n```\n1. 디자이너가 Figma에서 디자인 완성\n2. 링크 공유 (View 권한)\n3. 개발자는 Inspect로 수치 확인\n4. 이미지 Export\n5. 코드 구현\n```\n\n### 2. Dev Mode (개발 모드)\n\n2023년부터 추가된 기능으로, 개발자를 위한 전용 모드입니다.\n\n- CSS, iOS, Android 코드 자동 생성\n- Component 변경 사항 추적\n- 측정 도구 강화\n\n## 실전 예제: 버튼 컴포넌트\n\n```\n1. Rectangle 생성 (160 x 48)\n2. Border-radius: 8px\n3. Fill: Primary 색상\n4. Text 추가 (16px, Semibold)\n5. Auto Layout 적용 (Padding: 12px 24px)\n6. Component로 변환\n7. Variants 추가:\n   - State: default, hover, active\n   - Size: sm, md, lg\n```\n\n이렇게 만든 컴포넌트는 React나 Vue에서 그대로 구현할 수 있습니다!\n\n## 단축키 모음\n\n| 기능 | Mac | Windows |\n|------|-----|---------|\n| Frame | F | F |\n| Rectangle | R | R |\n| Text | T | T |\n| Component | Cmd+Opt+K | Ctrl+Alt+K |\n| Copy CSS | Cmd+C | Ctrl+C |\n| Zoom In | Cmd++ | Ctrl++ |\n| Zoom Out | Cmd+- | Ctrl+- |\n\n## 결론\n\nFigma는 개발자와 디자이너의 협업을 원활하게 만들어주는 도구입니다.\n기본 기능만 익혀도 충분히 활용할 수 있으니, 한번 시도해보세요! 🚀\n\n**공식 문서**: [figma.com/resources/learn-design](https://www.figma.com/resources/learn-design/)\n\n"
  },
  {
    "id": "2025-10-06-typescript-tips",
    "slug": "2025-10-06-typescript-tips",
    "title": "TypeScript 실전 팁 모음",
    "date": "2025-10-06",
    "category": "typescript",
    "subcategory": "frontend",
    "tags": [
      "TypeScript",
      "JavaScript",
      "개발팁"
    ],
    "excerpt": "실무에서 바로 사용할 수 있는 TypeScript 팁들을 모았습니다. 타입 가드, 유틸리티 타입, 제네릭 활용법 등을 다룹니다.",
    "author": "Geon Lee",
    "content": "<h1>TypeScript 실전 팁 모음 💎</h1>\n<p>실무에서 자주 사용하는 TypeScript 패턴과 팁들을 정리했습니다.</p>\n<h2>1. 타입 가드 (Type Guards)</h2>\n<p>런타임에서 타입을 좁혀나가는 방법입니다.</p>\n<pre><code class=\"language-typescript\">// typeof 사용\nfunction padLeft(value: string, padding: string | number) {\n  if (typeof padding === &quot;number&quot;) {\n    return Array(padding + 1).join(&quot; &quot;) + value;\n  }\n  return padding + value;\n}\n\n// instanceof 사용\nclass Dog {\n  bark() { console.log(&quot;멍멍!&quot;); }\n}\n\nclass Cat {\n  meow() { console.log(&quot;야옹~&quot;); }\n}\n\nfunction makeSound(animal: Dog | Cat) {\n  if (animal instanceof Dog) {\n    animal.bark();\n  } else {\n    animal.meow();\n  }\n}\n\n// 사용자 정의 타입 가드\ninterface Fish {\n  swim: () =&gt; void;\n}\n\ninterface Bird {\n  fly: () =&gt; void;\n}\n\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined;\n}\n</code></pre>\n<h2>2. 유틸리티 타입 활용</h2>\n<p>TypeScript에서 제공하는 내장 유틸리티 타입들입니다.</p>\n<pre><code class=\"language-typescript\">interface User {\n  id: number;\n  name: string;\n  email: string;\n  age?: number;\n}\n\n// Partial - 모든 속성을 선택적으로\ntype PartialUser = Partial&lt;User&gt;;\n// { id?: number; name?: string; email?: string; age?: number }\n\n// Required - 모든 속성을 필수로\ntype RequiredUser = Required&lt;User&gt;;\n// { id: number; name: string; email: string; age: number }\n\n// Pick - 특정 속성만 선택\ntype UserBasic = Pick&lt;User, &#39;id&#39; | &#39;name&#39;&gt;;\n// { id: number; name: string }\n\n// Omit - 특정 속성 제외\ntype UserWithoutEmail = Omit&lt;User, &#39;email&#39;&gt;;\n// { id: number; name: string; age?: number }\n\n// Record - 키-값 쌍 타입 생성\ntype PageInfo = Record&lt;&#39;home&#39; | &#39;about&#39; | &#39;contact&#39;, { title: string }&gt;;\n// { home: { title: string }, about: { title: string }, contact: { title: string } }\n</code></pre>\n<h2>3. 제네릭 활용</h2>\n<p>재사용 가능한 컴포넌트를 만들 때 필수입니다.</p>\n<pre><code class=\"language-typescript\">// 기본 제네릭 함수\nfunction identity&lt;T&gt;(arg: T): T {\n  return arg;\n}\n\n// 배열 제네릭\nfunction getFirstElement&lt;T&gt;(arr: T[]): T | undefined {\n  return arr[0];\n}\n\n// 제약 조건이 있는 제네릭\ninterface Lengthwise {\n  length: number;\n}\n\nfunction logLength&lt;T extends Lengthwise&gt;(arg: T): void {\n  console.log(arg.length);\n}\n\n// 클래스에서 제네릭 사용\nclass DataStore&lt;T&gt; {\n  private data: T[] = [];\n\n  add(item: T): void {\n    this.data.push(item);\n  }\n\n  get(index: number): T | undefined {\n    return this.data[index];\n  }\n\n  getAll(): T[] {\n    return [...this.data];\n  }\n}\n\nconst numberStore = new DataStore&lt;number&gt;();\nnumberStore.add(1);\nnumberStore.add(2);\n</code></pre>\n<h2>4. 고급 타입 패턴</h2>\n<h3>Union vs Intersection</h3>\n<pre><code class=\"language-typescript\">// Union (|) - 둘 중 하나\ntype Status = &#39;idle&#39; | &#39;loading&#39; | &#39;success&#39; | &#39;error&#39;;\n\n// Intersection (&amp;) - 모두 포함\ntype Admin = User &amp; {\n  permissions: string[];\n};\n</code></pre>\n<h3>Discriminated Union</h3>\n<pre><code class=\"language-typescript\">type Shape = \n  | { kind: &#39;circle&#39;; radius: number }\n  | { kind: &#39;square&#39;; size: number }\n  | { kind: &#39;rectangle&#39;; width: number; height: number };\n\nfunction area(shape: Shape): number {\n  switch (shape.kind) {\n    case &#39;circle&#39;:\n      return Math.PI * shape.radius ** 2;\n    case &#39;square&#39;:\n      return shape.size ** 2;\n    case &#39;rectangle&#39;:\n      return shape.width * shape.height;\n  }\n}\n</code></pre>\n<h3>Mapped Types</h3>\n<pre><code class=\"language-typescript\">type ReadOnly&lt;T&gt; = {\n  readonly [P in keyof T]: T[P];\n};\n\ntype Nullable&lt;T&gt; = {\n  [P in keyof T]: T[P] | null;\n};\n\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n}\n\ntype ReadonlyProduct = ReadOnly&lt;Product&gt;;\ntype NullableProduct = Nullable&lt;Product&gt;;\n</code></pre>\n<h2>5. 타입 추론 활용</h2>\n<pre><code class=\"language-typescript\">// 함수 반환 타입 추론\nconst createUser = () =&gt; ({\n  id: 1,\n  name: &#39;John&#39;,\n  email: &#39;john@example.com&#39;\n});\n\ntype User = ReturnType&lt;typeof createUser&gt;;\n// { id: number; name: string; email: string }\n\n// 매개변수 타입 추론\nfunction greet(name: string) {\n  return `Hello, ${name}`;\n}\n\ntype GreetParams = Parameters&lt;typeof greet&gt;;\n// [name: string]\n</code></pre>\n<h2>6. 실전 예제: API 응답 타입</h2>\n<pre><code class=\"language-typescript\">interface ApiResponse&lt;T&gt; {\n  data: T;\n  status: number;\n  message: string;\n}\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nasync function fetchUser(id: number): Promise&lt;ApiResponse&lt;User&gt;&gt; {\n  const response = await fetch(`/api/users/${id}`);\n  return response.json();\n}\n\n// 사용\nconst result = await fetchUser(1);\nconsole.log(result.data.name); // 타입 안전!\n</code></pre>\n<h2>결론</h2>\n<p>TypeScript를 잘 활용하면 코드의 안정성과 개발 생산성이 크게 향상됩니다.<br>타입 시스템을 제대로 이해하고 활용하는 것이 중요합니다! 🚀</p>\n",
    "rawContent": "\n# TypeScript 실전 팁 모음 💎\n\n실무에서 자주 사용하는 TypeScript 패턴과 팁들을 정리했습니다.\n\n## 1. 타입 가드 (Type Guards)\n\n런타임에서 타입을 좁혀나가는 방법입니다.\n\n```typescript\n// typeof 사용\nfunction padLeft(value: string, padding: string | number) {\n  if (typeof padding === \"number\") {\n    return Array(padding + 1).join(\" \") + value;\n  }\n  return padding + value;\n}\n\n// instanceof 사용\nclass Dog {\n  bark() { console.log(\"멍멍!\"); }\n}\n\nclass Cat {\n  meow() { console.log(\"야옹~\"); }\n}\n\nfunction makeSound(animal: Dog | Cat) {\n  if (animal instanceof Dog) {\n    animal.bark();\n  } else {\n    animal.meow();\n  }\n}\n\n// 사용자 정의 타입 가드\ninterface Fish {\n  swim: () => void;\n}\n\ninterface Bird {\n  fly: () => void;\n}\n\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined;\n}\n```\n\n## 2. 유틸리티 타입 활용\n\nTypeScript에서 제공하는 내장 유틸리티 타입들입니다.\n\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  age?: number;\n}\n\n// Partial - 모든 속성을 선택적으로\ntype PartialUser = Partial<User>;\n// { id?: number; name?: string; email?: string; age?: number }\n\n// Required - 모든 속성을 필수로\ntype RequiredUser = Required<User>;\n// { id: number; name: string; email: string; age: number }\n\n// Pick - 특정 속성만 선택\ntype UserBasic = Pick<User, 'id' | 'name'>;\n// { id: number; name: string }\n\n// Omit - 특정 속성 제외\ntype UserWithoutEmail = Omit<User, 'email'>;\n// { id: number; name: string; age?: number }\n\n// Record - 키-값 쌍 타입 생성\ntype PageInfo = Record<'home' | 'about' | 'contact', { title: string }>;\n// { home: { title: string }, about: { title: string }, contact: { title: string } }\n```\n\n## 3. 제네릭 활용\n\n재사용 가능한 컴포넌트를 만들 때 필수입니다.\n\n```typescript\n// 기본 제네릭 함수\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n\n// 배열 제네릭\nfunction getFirstElement<T>(arr: T[]): T | undefined {\n  return arr[0];\n}\n\n// 제약 조건이 있는 제네릭\ninterface Lengthwise {\n  length: number;\n}\n\nfunction logLength<T extends Lengthwise>(arg: T): void {\n  console.log(arg.length);\n}\n\n// 클래스에서 제네릭 사용\nclass DataStore<T> {\n  private data: T[] = [];\n\n  add(item: T): void {\n    this.data.push(item);\n  }\n\n  get(index: number): T | undefined {\n    return this.data[index];\n  }\n\n  getAll(): T[] {\n    return [...this.data];\n  }\n}\n\nconst numberStore = new DataStore<number>();\nnumberStore.add(1);\nnumberStore.add(2);\n```\n\n## 4. 고급 타입 패턴\n\n### Union vs Intersection\n\n```typescript\n// Union (|) - 둘 중 하나\ntype Status = 'idle' | 'loading' | 'success' | 'error';\n\n// Intersection (&) - 모두 포함\ntype Admin = User & {\n  permissions: string[];\n};\n```\n\n### Discriminated Union\n\n```typescript\ntype Shape = \n  | { kind: 'circle'; radius: number }\n  | { kind: 'square'; size: number }\n  | { kind: 'rectangle'; width: number; height: number };\n\nfunction area(shape: Shape): number {\n  switch (shape.kind) {\n    case 'circle':\n      return Math.PI * shape.radius ** 2;\n    case 'square':\n      return shape.size ** 2;\n    case 'rectangle':\n      return shape.width * shape.height;\n  }\n}\n```\n\n### Mapped Types\n\n```typescript\ntype ReadOnly<T> = {\n  readonly [P in keyof T]: T[P];\n};\n\ntype Nullable<T> = {\n  [P in keyof T]: T[P] | null;\n};\n\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n}\n\ntype ReadonlyProduct = ReadOnly<Product>;\ntype NullableProduct = Nullable<Product>;\n```\n\n## 5. 타입 추론 활용\n\n```typescript\n// 함수 반환 타입 추론\nconst createUser = () => ({\n  id: 1,\n  name: 'John',\n  email: 'john@example.com'\n});\n\ntype User = ReturnType<typeof createUser>;\n// { id: number; name: string; email: string }\n\n// 매개변수 타입 추론\nfunction greet(name: string) {\n  return `Hello, ${name}`;\n}\n\ntype GreetParams = Parameters<typeof greet>;\n// [name: string]\n```\n\n## 6. 실전 예제: API 응답 타입\n\n```typescript\ninterface ApiResponse<T> {\n  data: T;\n  status: number;\n  message: string;\n}\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nasync function fetchUser(id: number): Promise<ApiResponse<User>> {\n  const response = await fetch(`/api/users/${id}`);\n  return response.json();\n}\n\n// 사용\nconst result = await fetchUser(1);\nconsole.log(result.data.name); // 타입 안전!\n```\n\n## 결론\n\nTypeScript를 잘 활용하면 코드의 안정성과 개발 생산성이 크게 향상됩니다.\n타입 시스템을 제대로 이해하고 활용하는 것이 중요합니다! 🚀\n\n"
  },
  {
    "id": "2025-10-05-react-hooks",
    "slug": "2025-10-05-react-hooks",
    "title": "React Hooks 완벽 가이드",
    "date": "2025-10-05",
    "category": "react",
    "subcategory": "frontend",
    "tags": [
      "React",
      "Hooks",
      "JavaScript",
      "Frontend"
    ],
    "excerpt": "React Hooks의 기본부터 고급 활용법까지 모든 것을 알아봅니다. useState, useEffect, 커스텀 훅 등을 상세히 다룹니다.",
    "author": "Geon Lee",
    "content": "<h1>React Hooks 완벽 가이드</h1>\n<p>React Hooks는 함수형 컴포넌트에서 상태 관리와 생명주기 기능을 사용할 수 있게 해주는 혁신적인 기능입니다.</p>\n<h2>useState - 상태 관리의 시작</h2>\n<p>가장 기본적인 Hook인 <code>useState</code>를 사용하면 함수형 컴포넌트에서 상태를 관리할 수 있습니다.</p>\n<pre><code class=\"language-typescript\">import { useState } from &#39;react&#39;;\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Count: {count}&lt;/p&gt;\n      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;\n        증가\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>\n<h3>핵심 포인트</h3>\n<ul>\n<li><code>useState</code>는 배열을 반환합니다 (상태값, 업데이트 함수)</li>\n<li>초기값을 인자로 전달할 수 있습니다</li>\n<li>여러 개의 상태를 관리할 수 있습니다</li>\n</ul>\n<h2>useEffect - 사이드 이펙트 처리</h2>\n<p><code>useEffect</code>는 컴포넌트의 생명주기에 따라 특정 작업을 수행할 수 있게 해줍니다.</p>\n<pre><code class=\"language-typescript\">import { useEffect, useState } from &#39;react&#39;;\n\nfunction UserProfile({ userId }: { userId: string }) {\n  const [user, setUser] = useState(null);\n\n  useEffect(() =&gt; {\n    // 데이터 가져오기\n    fetch(`/api/users/${userId}`)\n      .then(res =&gt; res.json())\n      .then(setUser);\n\n    // 클린업 함수\n    return () =&gt; {\n      console.log(&#39;컴포넌트 언마운트&#39;);\n    };\n  }, [userId]); // 의존성 배열\n\n  return &lt;div&gt;{user?.name}&lt;/div&gt;;\n}\n</code></pre>\n<h3>useEffect의 의존성 배열</h3>\n<ul>\n<li><strong>빈 배열 <code>[]</code></strong>: 컴포넌트 마운트 시 1회만 실행</li>\n<li><strong>없음</strong>: 매 렌더링마다 실행</li>\n<li><strong>값 포함</strong>: 해당 값이 변경될 때마다 실행</li>\n</ul>\n<h2>커스텀 훅 만들기</h2>\n<p>자주 사용하는 로직을 커스텀 훅으로 만들면 재사용성이 높아집니다.</p>\n<pre><code class=\"language-typescript\">import { useState, useEffect } from &#39;react&#39;;\n\nfunction useFetch&lt;T&gt;(url: string) {\n  const [data, setData] = useState&lt;T | null&gt;(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState&lt;Error | null&gt;(null);\n\n  useEffect(() =&gt; {\n    fetch(url)\n      .then(res =&gt; res.json())\n      .then(data =&gt; {\n        setData(data);\n        setLoading(false);\n      })\n      .catch(err =&gt; {\n        setError(err);\n        setLoading(false);\n      });\n  }, [url]);\n\n  return { data, loading, error };\n}\n\n// 사용\nfunction MyComponent() {\n  const { data, loading } = useFetch&lt;User&gt;(&#39;/api/user&#39;);\n  \n  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n  return &lt;div&gt;{data?.name}&lt;/div&gt;;\n}\n</code></pre>\n<h2>기타 유용한 Hooks</h2>\n<h3>useCallback</h3>\n<p>함수를 메모이제이션하여 불필요한 리렌더링을 방지합니다.</p>\n<pre><code class=\"language-typescript\">const handleClick = useCallback(() =&gt; {\n  console.log(value);\n}, [value]);\n</code></pre>\n<h3>useMemo</h3>\n<p>계산 비용이 큰 값을 메모이제이션합니다.</p>\n<pre><code class=\"language-typescript\">const expensiveValue = useMemo(() =&gt; {\n  return computeExpensiveValue(a, b);\n}, [a, b]);\n</code></pre>\n<h3>useRef</h3>\n<p>DOM 요소에 직접 접근하거나 값을 유지합니다.</p>\n<pre><code class=\"language-typescript\">const inputRef = useRef&lt;HTMLInputElement&gt;(null);\n\nconst focusInput = () =&gt; {\n  inputRef.current?.focus();\n};\n</code></pre>\n<h2>결론</h2>\n<p>React Hooks는 함수형 컴포넌트를 더욱 강력하게 만들어줍니다.<br>클래스 컴포넌트 없이도 모든 기능을 구현할 수 있으며, 코드의 재사용성과 가독성이 크게 향상됩니다.</p>\n<p>더 많은 정보는 <a href=\"https://react.dev\">공식 React 문서</a>를 참고하세요!</p>\n",
    "rawContent": "\n# React Hooks 완벽 가이드\n\nReact Hooks는 함수형 컴포넌트에서 상태 관리와 생명주기 기능을 사용할 수 있게 해주는 혁신적인 기능입니다.\n\n## useState - 상태 관리의 시작\n\n가장 기본적인 Hook인 `useState`를 사용하면 함수형 컴포넌트에서 상태를 관리할 수 있습니다.\n\n```typescript\nimport { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>\n        증가\n      </button>\n    </div>\n  );\n}\n```\n\n### 핵심 포인트\n\n- `useState`는 배열을 반환합니다 (상태값, 업데이트 함수)\n- 초기값을 인자로 전달할 수 있습니다\n- 여러 개의 상태를 관리할 수 있습니다\n\n## useEffect - 사이드 이펙트 처리\n\n`useEffect`는 컴포넌트의 생명주기에 따라 특정 작업을 수행할 수 있게 해줍니다.\n\n```typescript\nimport { useEffect, useState } from 'react';\n\nfunction UserProfile({ userId }: { userId: string }) {\n  const [user, setUser] = useState(null);\n\n  useEffect(() => {\n    // 데이터 가져오기\n    fetch(`/api/users/${userId}`)\n      .then(res => res.json())\n      .then(setUser);\n\n    // 클린업 함수\n    return () => {\n      console.log('컴포넌트 언마운트');\n    };\n  }, [userId]); // 의존성 배열\n\n  return <div>{user?.name}</div>;\n}\n```\n\n### useEffect의 의존성 배열\n\n- **빈 배열 `[]`**: 컴포넌트 마운트 시 1회만 실행\n- **없음**: 매 렌더링마다 실행\n- **값 포함**: 해당 값이 변경될 때마다 실행\n\n## 커스텀 훅 만들기\n\n자주 사용하는 로직을 커스텀 훅으로 만들면 재사용성이 높아집니다.\n\n```typescript\nimport { useState, useEffect } from 'react';\n\nfunction useFetch<T>(url: string) {\n  const [data, setData] = useState<T | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n\n  useEffect(() => {\n    fetch(url)\n      .then(res => res.json())\n      .then(data => {\n        setData(data);\n        setLoading(false);\n      })\n      .catch(err => {\n        setError(err);\n        setLoading(false);\n      });\n  }, [url]);\n\n  return { data, loading, error };\n}\n\n// 사용\nfunction MyComponent() {\n  const { data, loading } = useFetch<User>('/api/user');\n  \n  if (loading) return <div>Loading...</div>;\n  return <div>{data?.name}</div>;\n}\n```\n\n## 기타 유용한 Hooks\n\n### useCallback\n\n함수를 메모이제이션하여 불필요한 리렌더링을 방지합니다.\n\n```typescript\nconst handleClick = useCallback(() => {\n  console.log(value);\n}, [value]);\n```\n\n### useMemo\n\n계산 비용이 큰 값을 메모이제이션합니다.\n\n```typescript\nconst expensiveValue = useMemo(() => {\n  return computeExpensiveValue(a, b);\n}, [a, b]);\n```\n\n### useRef\n\nDOM 요소에 직접 접근하거나 값을 유지합니다.\n\n```typescript\nconst inputRef = useRef<HTMLInputElement>(null);\n\nconst focusInput = () => {\n  inputRef.current?.focus();\n};\n```\n\n## 결론\n\nReact Hooks는 함수형 컴포넌트를 더욱 강력하게 만들어줍니다. \n클래스 컴포넌트 없이도 모든 기능을 구현할 수 있으며, 코드의 재사용성과 가독성이 크게 향상됩니다.\n\n더 많은 정보는 [공식 React 문서](https://react.dev)를 참고하세요!\n\n"
  },
  {
    "id": "2025-10-01-welcome",
    "slug": "2025-10-01-welcome",
    "title": "블로그에 오신 것을 환영합니다!",
    "date": "2025-10-01",
    "category": "life",
    "subcategory": null,
    "tags": [
      "블로그",
      "시작",
      "환영"
    ],
    "excerpt": "새로운 블로그를 시작합니다. 개발, 디자인, 그리고 일상에 대한 이야기를 공유할 예정입니다.",
    "author": "Geon Lee",
    "content": "<h1>블로그에 오신 것을 환영합니다! 👋</h1>\n<p>안녕하세요! 이 블로그의 첫 번째 포스트입니다.</p>\n<h2>블로그 소개</h2>\n<p>이 블로그에서는 다음과 같은 내용을 다룰 예정입니다:</p>\n<ul>\n<li>🚀 <strong>개발</strong>: React, TypeScript, Node.js 등 프론트엔드 개발 관련 글</li>\n<li>🎨 <strong>디자인</strong>: UI/UX 디자인과 Figma 활용 팁</li>\n<li>💡 <strong>일상</strong>: 개발자의 삶과 생각들</li>\n</ul>\n<h2>기술 스택</h2>\n<p>이 블로그는 다음 기술로 만들어졌습니다:</p>\n<ul>\n<li>React + TypeScript</li>\n<li>Vite</li>\n<li>Tailwind CSS</li>\n<li>shadcn/ui</li>\n<li>GitHub Pages</li>\n</ul>\n<h2>앞으로의 계획</h2>\n<p>앞으로 다양한 주제의 글을 꾸준히 올릴 예정입니다.<br>방문해주셔서 감사합니다! 🙏</p>\n",
    "rawContent": "\n# 블로그에 오신 것을 환영합니다! 👋\n\n안녕하세요! 이 블로그의 첫 번째 포스트입니다.\n\n## 블로그 소개\n\n이 블로그에서는 다음과 같은 내용을 다룰 예정입니다:\n\n- 🚀 **개발**: React, TypeScript, Node.js 등 프론트엔드 개발 관련 글\n- 🎨 **디자인**: UI/UX 디자인과 Figma 활용 팁\n- 💡 **일상**: 개발자의 삶과 생각들\n\n## 기술 스택\n\n이 블로그는 다음 기술로 만들어졌습니다:\n\n- React + TypeScript\n- Vite\n- Tailwind CSS\n- shadcn/ui\n- GitHub Pages\n\n## 앞으로의 계획\n\n앞으로 다양한 주제의 글을 꾸준히 올릴 예정입니다. \n방문해주셔서 감사합니다! 🙏\n\n"
  }
]
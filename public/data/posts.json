[
  {
    "id": "2025-10-12-data-structure-essentials",
    "slug": "2025-10-12-data-structure-essentials",
    "title": "자료구조 핵심 개념과 구현",
    "date": "2025-10-12",
    "category": "CS",
    "subcategory": "Structure",
    "tags": [
      "Data Structure",
      "Algorithm",
      "Computer Science",
      "Implementation"
    ],
    "excerpt": "스택, 큐, 트리, 그래프 등 핵심 자료구조의 개념과 JavaScript로 구현하는 방법을 배웁니다.",
    "author": "Geon Lee",
    "content": "<h1>자료구조 핵심 개념과 구현</h1>\n<p>자료구조는 데이터를 효율적으로 저장하고 관리하기 위한 방법입니다.</p>\n<h2>배열 (Array)</h2>\n<p>연속된 메모리 공간에 데이터를 저장하는 선형 자료구조입니다.</p>\n<pre><code class=\"language-javascript\">// 시간 복잡도\n// 접근: O(1)\n// 탐색: O(n)\n// 삽입/삭제: O(n)\n\nconst arr = [1, 2, 3, 4, 5];\n\n// 접근\nconsole.log(arr[2]);  // O(1)\n\n// 탐색\nconst index = arr.indexOf(3);  // O(n)\n\n// 삽입\narr.push(6);       // O(1) - 끝에 추가\narr.unshift(0);    // O(n) - 앞에 추가\narr.splice(2, 0, 10);  // O(n) - 중간에 추가\n\n// 삭제\narr.pop();         // O(1) - 끝에서 삭제\narr.shift();       // O(n) - 앞에서 삭제\narr.splice(2, 1);  // O(n) - 중간에서 삭제\n</code></pre>\n<h2>연결 리스트 (Linked List)</h2>\n<p>노드들이 포인터로 연결된 선형 자료구조입니다.</p>\n<pre><code class=\"language-javascript\">class Node {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nclass LinkedList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n  \n  // 끝에 추가: O(1)\n  append(value) {\n    const node = new Node(value);\n    \n    if (!this.head) {\n      this.head = node;\n      this.tail = node;\n    } else {\n      this.tail.next = node;\n      this.tail = node;\n    }\n    \n    this.length++;\n  }\n  \n  // 앞에 추가: O(1)\n  prepend(value) {\n    const node = new Node(value);\n    \n    if (!this.head) {\n      this.head = node;\n      this.tail = node;\n    } else {\n      node.next = this.head;\n      this.head = node;\n    }\n    \n    this.length++;\n  }\n  \n  // 특정 위치에 삽입: O(n)\n  insertAt(index, value) {\n    if (index &lt; 0 || index &gt; this.length) return false;\n    if (index === 0) return this.prepend(value);\n    if (index === this.length) return this.append(value);\n    \n    const node = new Node(value);\n    let current = this.head;\n    \n    for (let i = 0; i &lt; index - 1; i++) {\n      current = current.next;\n    }\n    \n    node.next = current.next;\n    current.next = node;\n    this.length++;\n  }\n  \n  // 삭제: O(n)\n  remove(value) {\n    if (!this.head) return null;\n    \n    if (this.head.value === value) {\n      this.head = this.head.next;\n      this.length--;\n      return value;\n    }\n    \n    let current = this.head;\n    while (current.next) {\n      if (current.next.value === value) {\n        current.next = current.next.next;\n        if (!current.next) this.tail = current;\n        this.length--;\n        return value;\n      }\n      current = current.next;\n    }\n    \n    return null;\n  }\n  \n  // 탐색: O(n)\n  find(value) {\n    let current = this.head;\n    while (current) {\n      if (current.value === value) return current;\n      current = current.next;\n    }\n    return null;\n  }\n  \n  // 배열로 변환\n  toArray() {\n    const arr = [];\n    let current = this.head;\n    while (current) {\n      arr.push(current.value);\n      current = current.next;\n    }\n    return arr;\n  }\n}\n</code></pre>\n<h2>스택 (Stack)</h2>\n<p>LIFO (Last In First Out) 방식의 자료구조입니다.</p>\n<pre><code class=\"language-javascript\">class Stack {\n  constructor() {\n    this.items = [];\n  }\n  \n  // 추가: O(1)\n  push(element) {\n    this.items.push(element);\n  }\n  \n  // 제거: O(1)\n  pop() {\n    if (this.isEmpty()) return null;\n    return this.items.pop();\n  }\n  \n  // 최상단 확인: O(1)\n  peek() {\n    if (this.isEmpty()) return null;\n    return this.items[this.items.length - 1];\n  }\n  \n  isEmpty() {\n    return this.items.length === 0;\n  }\n  \n  size() {\n    return this.items.length;\n  }\n  \n  clear() {\n    this.items = [];\n  }\n}\n\n// 활용 예제: 괄호 검사\nfunction isValidParentheses(str) {\n  const stack = new Stack();\n  const pairs = { &#39;(&#39;: &#39;)&#39;, &#39;[&#39;: &#39;]&#39;, &#39;{&#39;: &#39;}&#39; };\n  \n  for (const char of str) {\n    if (char in pairs) {\n      stack.push(char);\n    } else if (Object.values(pairs).includes(char)) {\n      if (stack.isEmpty() || pairs[stack.pop()] !== char) {\n        return false;\n      }\n    }\n  }\n  \n  return stack.isEmpty();\n}\n</code></pre>\n<h2>큐 (Queue)</h2>\n<p>FIFO (First In First Out) 방식의 자료구조입니다.</p>\n<pre><code class=\"language-javascript\">class Queue {\n  constructor() {\n    this.items = {};\n    this.frontIndex = 0;\n    this.backIndex = 0;\n  }\n  \n  // 추가: O(1)\n  enqueue(element) {\n    this.items[this.backIndex] = element;\n    this.backIndex++;\n  }\n  \n  // 제거: O(1)\n  dequeue() {\n    if (this.isEmpty()) return null;\n    \n    const item = this.items[this.frontIndex];\n    delete this.items[this.frontIndex];\n    this.frontIndex++;\n    return item;\n  }\n  \n  // 앞 확인: O(1)\n  peek() {\n    if (this.isEmpty()) return null;\n    return this.items[this.frontIndex];\n  }\n  \n  isEmpty() {\n    return this.backIndex === this.frontIndex;\n  }\n  \n  size() {\n    return this.backIndex - this.frontIndex;\n  }\n}\n\n// 우선순위 큐\nclass PriorityQueue {\n  constructor() {\n    this.items = [];\n  }\n  \n  enqueue(element, priority) {\n    const queueElement = { element, priority };\n    let added = false;\n    \n    for (let i = 0; i &lt; this.items.length; i++) {\n      if (queueElement.priority &lt; this.items[i].priority) {\n        this.items.splice(i, 0, queueElement);\n        added = true;\n        break;\n      }\n    }\n    \n    if (!added) {\n      this.items.push(queueElement);\n    }\n  }\n  \n  dequeue() {\n    if (this.isEmpty()) return null;\n    return this.items.shift();\n  }\n  \n  isEmpty() {\n    return this.items.length === 0;\n  }\n}\n</code></pre>\n<h2>해시 테이블 (Hash Table)</h2>\n<p>키-값 쌍으로 데이터를 저장하는 자료구조입니다.</p>\n<pre><code class=\"language-javascript\">class HashTable {\n  constructor(size = 53) {\n    this.keyMap = new Array(size);\n  }\n  \n  // 해시 함수\n  _hash(key) {\n    let total = 0;\n    const PRIME = 31;\n    \n    for (let i = 0; i &lt; Math.min(key.length, 100); i++) {\n      const char = key[i];\n      const value = char.charCodeAt(0) - 96;\n      total = (total * PRIME + value) % this.keyMap.length;\n    }\n    \n    return total;\n  }\n  \n  // 삽입: O(1) 평균\n  set(key, value) {\n    const index = this._hash(key);\n    \n    if (!this.keyMap[index]) {\n      this.keyMap[index] = [];\n    }\n    \n    // 충돌 처리: Separate Chaining\n    const bucket = this.keyMap[index];\n    for (let i = 0; i &lt; bucket.length; i++) {\n      if (bucket[i][0] === key) {\n        bucket[i][1] = value;\n        return;\n      }\n    }\n    \n    bucket.push([key, value]);\n  }\n  \n  // 조회: O(1) 평균\n  get(key) {\n    const index = this._hash(key);\n    const bucket = this.keyMap[index];\n    \n    if (bucket) {\n      for (const [k, v] of bucket) {\n        if (k === key) return v;\n      }\n    }\n    \n    return undefined;\n  }\n  \n  // 삭제: O(1) 평균\n  delete(key) {\n    const index = this._hash(key);\n    const bucket = this.keyMap[index];\n    \n    if (bucket) {\n      for (let i = 0; i &lt; bucket.length; i++) {\n        if (bucket[i][0] === key) {\n          bucket.splice(i, 1);\n          return true;\n        }\n      }\n    }\n    \n    return false;\n  }\n  \n  // 모든 키\n  keys() {\n    const keys = [];\n    for (const bucket of this.keyMap) {\n      if (bucket) {\n        for (const [key] of bucket) {\n          keys.push(key);\n        }\n      }\n    }\n    return keys;\n  }\n  \n  // 모든 값\n  values() {\n    const values = [];\n    const seen = new Set();\n    \n    for (const bucket of this.keyMap) {\n      if (bucket) {\n        for (const [, value] of bucket) {\n          if (!seen.has(value)) {\n            values.push(value);\n            seen.add(value);\n          }\n        }\n      }\n    }\n    \n    return values;\n  }\n}\n</code></pre>\n<h2>이진 트리 (Binary Tree)</h2>\n<p>각 노드가 최대 2개의 자식을 가지는 트리 구조입니다.</p>\n<pre><code class=\"language-javascript\">class TreeNode {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nclass BinarySearchTree {\n  constructor() {\n    this.root = null;\n  }\n  \n  // 삽입: O(log n) 평균, O(n) 최악\n  insert(value) {\n    const newNode = new TreeNode(value);\n    \n    if (!this.root) {\n      this.root = newNode;\n      return this;\n    }\n    \n    let current = this.root;\n    while (true) {\n      if (value === current.value) return undefined;\n      \n      if (value &lt; current.value) {\n        if (!current.left) {\n          current.left = newNode;\n          return this;\n        }\n        current = current.left;\n      } else {\n        if (!current.right) {\n          current.right = newNode;\n          return this;\n        }\n        current = current.right;\n      }\n    }\n  }\n  \n  // 탐색: O(log n) 평균\n  find(value) {\n    if (!this.root) return null;\n    \n    let current = this.root;\n    while (current) {\n      if (value === current.value) return current;\n      current = value &lt; current.value ? current.left : current.right;\n    }\n    \n    return null;\n  }\n  \n  // 중위 순회 (Inorder): 왼쪽 → 루트 → 오른쪽\n  inorder(node = this.root, result = []) {\n    if (node) {\n      this.inorder(node.left, result);\n      result.push(node.value);\n      this.inorder(node.right, result);\n    }\n    return result;\n  }\n  \n  // 전위 순회 (Preorder): 루트 → 왼쪽 → 오른쪽\n  preorder(node = this.root, result = []) {\n    if (node) {\n      result.push(node.value);\n      this.preorder(node.left, result);\n      this.preorder(node.right, result);\n    }\n    return result;\n  }\n  \n  // 후위 순회 (Postorder): 왼쪽 → 오른쪽 → 루트\n  postorder(node = this.root, result = []) {\n    if (node) {\n      this.postorder(node.left, result);\n      this.postorder(node.right, result);\n      result.push(node.value);\n    }\n    return result;\n  }\n  \n  // 레벨 순회 (BFS)\n  levelOrder() {\n    if (!this.root) return [];\n    \n    const result = [];\n    const queue = [this.root];\n    \n    while (queue.length &gt; 0) {\n      const node = queue.shift();\n      result.push(node.value);\n      \n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n    \n    return result;\n  }\n}\n</code></pre>\n<h2>힙 (Heap)</h2>\n<p>완전 이진 트리 기반의 자료구조입니다.</p>\n<pre><code class=\"language-javascript\">class MaxHeap {\n  constructor() {\n    this.heap = [];\n  }\n  \n  // 부모 인덱스\n  getParentIndex(i) {\n    return Math.floor((i - 1) / 2);\n  }\n  \n  // 자식 인덱스\n  getLeftChildIndex(i) {\n    return 2 * i + 1;\n  }\n  \n  getRightChildIndex(i) {\n    return 2 * i + 2;\n  }\n  \n  // 삽입: O(log n)\n  insert(value) {\n    this.heap.push(value);\n    this.bubbleUp(this.heap.length - 1);\n  }\n  \n  bubbleUp(index) {\n    while (index &gt; 0) {\n      const parentIndex = this.getParentIndex(index);\n      \n      if (this.heap[parentIndex] &gt;= this.heap[index]) break;\n      \n      [this.heap[parentIndex], this.heap[index]] = \n        [this.heap[index], this.heap[parentIndex]];\n      \n      index = parentIndex;\n    }\n  }\n  \n  // 최대값 추출: O(log n)\n  extractMax() {\n    if (this.heap.length === 0) return null;\n    if (this.heap.length === 1) return this.heap.pop();\n    \n    const max = this.heap[0];\n    this.heap[0] = this.heap.pop();\n    this.bubbleDown(0);\n    \n    return max;\n  }\n  \n  bubbleDown(index) {\n    while (true) {\n      let largest = index;\n      const leftIndex = this.getLeftChildIndex(index);\n      const rightIndex = this.getRightChildIndex(index);\n      \n      if (leftIndex &lt; this.heap.length &amp;&amp; \n          this.heap[leftIndex] &gt; this.heap[largest]) {\n        largest = leftIndex;\n      }\n      \n      if (rightIndex &lt; this.heap.length &amp;&amp; \n          this.heap[rightIndex] &gt; this.heap[largest]) {\n        largest = rightIndex;\n      }\n      \n      if (largest === index) break;\n      \n      [this.heap[index], this.heap[largest]] = \n        [this.heap[largest], this.heap[index]];\n      \n      index = largest;\n    }\n  }\n  \n  // 최대값 확인: O(1)\n  peek() {\n    return this.heap[0] || null;\n  }\n}\n</code></pre>\n<h2>그래프 (Graph)</h2>\n<p>노드와 간선으로 연결된 자료구조입니다.</p>\n<pre><code class=\"language-javascript\">class Graph {\n  constructor() {\n    this.adjacencyList = {};\n  }\n  \n  // 정점 추가: O(1)\n  addVertex(vertex) {\n    if (!this.adjacencyList[vertex]) {\n      this.adjacencyList[vertex] = [];\n    }\n  }\n  \n  // 간선 추가: O(1)\n  addEdge(v1, v2) {\n    this.adjacencyList[v1].push(v2);\n    this.adjacencyList[v2].push(v1);  // 무방향 그래프\n  }\n  \n  // 간선 제거: O(E)\n  removeEdge(v1, v2) {\n    this.adjacencyList[v1] = this.adjacencyList[v1].filter(v =&gt; v !== v2);\n    this.adjacencyList[v2] = this.adjacencyList[v2].filter(v =&gt; v !== v1);\n  }\n  \n  // 정점 제거: O(V + E)\n  removeVertex(vertex) {\n    while (this.adjacencyList[vertex].length) {\n      const adjacentVertex = this.adjacencyList[vertex].pop();\n      this.removeEdge(vertex, adjacentVertex);\n    }\n    delete this.adjacencyList[vertex];\n  }\n  \n  // DFS\n  dfs(start) {\n    const result = [];\n    const visited = {};\n    \n    const traverse = (vertex) =&gt; {\n      if (!vertex) return;\n      \n      visited[vertex] = true;\n      result.push(vertex);\n      \n      for (const neighbor of this.adjacencyList[vertex]) {\n        if (!visited[neighbor]) {\n          traverse(neighbor);\n        }\n      }\n    };\n    \n    traverse(start);\n    return result;\n  }\n  \n  // BFS\n  bfs(start) {\n    const queue = [start];\n    const result = [];\n    const visited = { [start]: true };\n    \n    while (queue.length) {\n      const vertex = queue.shift();\n      result.push(vertex);\n      \n      for (const neighbor of this.adjacencyList[vertex]) {\n        if (!visited[neighbor]) {\n          visited[neighbor] = true;\n          queue.push(neighbor);\n        }\n      }\n    }\n    \n    return result;\n  }\n}\n</code></pre>\n<h2>결론</h2>\n<p>자료구조는 프로그래밍의 기초이자 핵심입니다.<br>각 자료구조의 특성을 이해하고 상황에 맞게 선택하는 것이 중요합니다.<br>시간 복잡도와 공간 복잡도를 고려하여 최적의 자료구조를 사용하면 효율적인 프로그램을 작성할 수 있습니다! 🚀</p>\n",
    "rawContent": "\n# 자료구조 핵심 개념과 구현\n\n자료구조는 데이터를 효율적으로 저장하고 관리하기 위한 방법입니다.\n\n## 배열 (Array)\n\n연속된 메모리 공간에 데이터를 저장하는 선형 자료구조입니다.\n\n```javascript\n// 시간 복잡도\n// 접근: O(1)\n// 탐색: O(n)\n// 삽입/삭제: O(n)\n\nconst arr = [1, 2, 3, 4, 5];\n\n// 접근\nconsole.log(arr[2]);  // O(1)\n\n// 탐색\nconst index = arr.indexOf(3);  // O(n)\n\n// 삽입\narr.push(6);       // O(1) - 끝에 추가\narr.unshift(0);    // O(n) - 앞에 추가\narr.splice(2, 0, 10);  // O(n) - 중간에 추가\n\n// 삭제\narr.pop();         // O(1) - 끝에서 삭제\narr.shift();       // O(n) - 앞에서 삭제\narr.splice(2, 1);  // O(n) - 중간에서 삭제\n```\n\n## 연결 리스트 (Linked List)\n\n노드들이 포인터로 연결된 선형 자료구조입니다.\n\n```javascript\nclass Node {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nclass LinkedList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n  \n  // 끝에 추가: O(1)\n  append(value) {\n    const node = new Node(value);\n    \n    if (!this.head) {\n      this.head = node;\n      this.tail = node;\n    } else {\n      this.tail.next = node;\n      this.tail = node;\n    }\n    \n    this.length++;\n  }\n  \n  // 앞에 추가: O(1)\n  prepend(value) {\n    const node = new Node(value);\n    \n    if (!this.head) {\n      this.head = node;\n      this.tail = node;\n    } else {\n      node.next = this.head;\n      this.head = node;\n    }\n    \n    this.length++;\n  }\n  \n  // 특정 위치에 삽입: O(n)\n  insertAt(index, value) {\n    if (index < 0 || index > this.length) return false;\n    if (index === 0) return this.prepend(value);\n    if (index === this.length) return this.append(value);\n    \n    const node = new Node(value);\n    let current = this.head;\n    \n    for (let i = 0; i < index - 1; i++) {\n      current = current.next;\n    }\n    \n    node.next = current.next;\n    current.next = node;\n    this.length++;\n  }\n  \n  // 삭제: O(n)\n  remove(value) {\n    if (!this.head) return null;\n    \n    if (this.head.value === value) {\n      this.head = this.head.next;\n      this.length--;\n      return value;\n    }\n    \n    let current = this.head;\n    while (current.next) {\n      if (current.next.value === value) {\n        current.next = current.next.next;\n        if (!current.next) this.tail = current;\n        this.length--;\n        return value;\n      }\n      current = current.next;\n    }\n    \n    return null;\n  }\n  \n  // 탐색: O(n)\n  find(value) {\n    let current = this.head;\n    while (current) {\n      if (current.value === value) return current;\n      current = current.next;\n    }\n    return null;\n  }\n  \n  // 배열로 변환\n  toArray() {\n    const arr = [];\n    let current = this.head;\n    while (current) {\n      arr.push(current.value);\n      current = current.next;\n    }\n    return arr;\n  }\n}\n```\n\n## 스택 (Stack)\n\nLIFO (Last In First Out) 방식의 자료구조입니다.\n\n```javascript\nclass Stack {\n  constructor() {\n    this.items = [];\n  }\n  \n  // 추가: O(1)\n  push(element) {\n    this.items.push(element);\n  }\n  \n  // 제거: O(1)\n  pop() {\n    if (this.isEmpty()) return null;\n    return this.items.pop();\n  }\n  \n  // 최상단 확인: O(1)\n  peek() {\n    if (this.isEmpty()) return null;\n    return this.items[this.items.length - 1];\n  }\n  \n  isEmpty() {\n    return this.items.length === 0;\n  }\n  \n  size() {\n    return this.items.length;\n  }\n  \n  clear() {\n    this.items = [];\n  }\n}\n\n// 활용 예제: 괄호 검사\nfunction isValidParentheses(str) {\n  const stack = new Stack();\n  const pairs = { '(': ')', '[': ']', '{': '}' };\n  \n  for (const char of str) {\n    if (char in pairs) {\n      stack.push(char);\n    } else if (Object.values(pairs).includes(char)) {\n      if (stack.isEmpty() || pairs[stack.pop()] !== char) {\n        return false;\n      }\n    }\n  }\n  \n  return stack.isEmpty();\n}\n```\n\n## 큐 (Queue)\n\nFIFO (First In First Out) 방식의 자료구조입니다.\n\n```javascript\nclass Queue {\n  constructor() {\n    this.items = {};\n    this.frontIndex = 0;\n    this.backIndex = 0;\n  }\n  \n  // 추가: O(1)\n  enqueue(element) {\n    this.items[this.backIndex] = element;\n    this.backIndex++;\n  }\n  \n  // 제거: O(1)\n  dequeue() {\n    if (this.isEmpty()) return null;\n    \n    const item = this.items[this.frontIndex];\n    delete this.items[this.frontIndex];\n    this.frontIndex++;\n    return item;\n  }\n  \n  // 앞 확인: O(1)\n  peek() {\n    if (this.isEmpty()) return null;\n    return this.items[this.frontIndex];\n  }\n  \n  isEmpty() {\n    return this.backIndex === this.frontIndex;\n  }\n  \n  size() {\n    return this.backIndex - this.frontIndex;\n  }\n}\n\n// 우선순위 큐\nclass PriorityQueue {\n  constructor() {\n    this.items = [];\n  }\n  \n  enqueue(element, priority) {\n    const queueElement = { element, priority };\n    let added = false;\n    \n    for (let i = 0; i < this.items.length; i++) {\n      if (queueElement.priority < this.items[i].priority) {\n        this.items.splice(i, 0, queueElement);\n        added = true;\n        break;\n      }\n    }\n    \n    if (!added) {\n      this.items.push(queueElement);\n    }\n  }\n  \n  dequeue() {\n    if (this.isEmpty()) return null;\n    return this.items.shift();\n  }\n  \n  isEmpty() {\n    return this.items.length === 0;\n  }\n}\n```\n\n## 해시 테이블 (Hash Table)\n\n키-값 쌍으로 데이터를 저장하는 자료구조입니다.\n\n```javascript\nclass HashTable {\n  constructor(size = 53) {\n    this.keyMap = new Array(size);\n  }\n  \n  // 해시 함수\n  _hash(key) {\n    let total = 0;\n    const PRIME = 31;\n    \n    for (let i = 0; i < Math.min(key.length, 100); i++) {\n      const char = key[i];\n      const value = char.charCodeAt(0) - 96;\n      total = (total * PRIME + value) % this.keyMap.length;\n    }\n    \n    return total;\n  }\n  \n  // 삽입: O(1) 평균\n  set(key, value) {\n    const index = this._hash(key);\n    \n    if (!this.keyMap[index]) {\n      this.keyMap[index] = [];\n    }\n    \n    // 충돌 처리: Separate Chaining\n    const bucket = this.keyMap[index];\n    for (let i = 0; i < bucket.length; i++) {\n      if (bucket[i][0] === key) {\n        bucket[i][1] = value;\n        return;\n      }\n    }\n    \n    bucket.push([key, value]);\n  }\n  \n  // 조회: O(1) 평균\n  get(key) {\n    const index = this._hash(key);\n    const bucket = this.keyMap[index];\n    \n    if (bucket) {\n      for (const [k, v] of bucket) {\n        if (k === key) return v;\n      }\n    }\n    \n    return undefined;\n  }\n  \n  // 삭제: O(1) 평균\n  delete(key) {\n    const index = this._hash(key);\n    const bucket = this.keyMap[index];\n    \n    if (bucket) {\n      for (let i = 0; i < bucket.length; i++) {\n        if (bucket[i][0] === key) {\n          bucket.splice(i, 1);\n          return true;\n        }\n      }\n    }\n    \n    return false;\n  }\n  \n  // 모든 키\n  keys() {\n    const keys = [];\n    for (const bucket of this.keyMap) {\n      if (bucket) {\n        for (const [key] of bucket) {\n          keys.push(key);\n        }\n      }\n    }\n    return keys;\n  }\n  \n  // 모든 값\n  values() {\n    const values = [];\n    const seen = new Set();\n    \n    for (const bucket of this.keyMap) {\n      if (bucket) {\n        for (const [, value] of bucket) {\n          if (!seen.has(value)) {\n            values.push(value);\n            seen.add(value);\n          }\n        }\n      }\n    }\n    \n    return values;\n  }\n}\n```\n\n## 이진 트리 (Binary Tree)\n\n각 노드가 최대 2개의 자식을 가지는 트리 구조입니다.\n\n```javascript\nclass TreeNode {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nclass BinarySearchTree {\n  constructor() {\n    this.root = null;\n  }\n  \n  // 삽입: O(log n) 평균, O(n) 최악\n  insert(value) {\n    const newNode = new TreeNode(value);\n    \n    if (!this.root) {\n      this.root = newNode;\n      return this;\n    }\n    \n    let current = this.root;\n    while (true) {\n      if (value === current.value) return undefined;\n      \n      if (value < current.value) {\n        if (!current.left) {\n          current.left = newNode;\n          return this;\n        }\n        current = current.left;\n      } else {\n        if (!current.right) {\n          current.right = newNode;\n          return this;\n        }\n        current = current.right;\n      }\n    }\n  }\n  \n  // 탐색: O(log n) 평균\n  find(value) {\n    if (!this.root) return null;\n    \n    let current = this.root;\n    while (current) {\n      if (value === current.value) return current;\n      current = value < current.value ? current.left : current.right;\n    }\n    \n    return null;\n  }\n  \n  // 중위 순회 (Inorder): 왼쪽 → 루트 → 오른쪽\n  inorder(node = this.root, result = []) {\n    if (node) {\n      this.inorder(node.left, result);\n      result.push(node.value);\n      this.inorder(node.right, result);\n    }\n    return result;\n  }\n  \n  // 전위 순회 (Preorder): 루트 → 왼쪽 → 오른쪽\n  preorder(node = this.root, result = []) {\n    if (node) {\n      result.push(node.value);\n      this.preorder(node.left, result);\n      this.preorder(node.right, result);\n    }\n    return result;\n  }\n  \n  // 후위 순회 (Postorder): 왼쪽 → 오른쪽 → 루트\n  postorder(node = this.root, result = []) {\n    if (node) {\n      this.postorder(node.left, result);\n      this.postorder(node.right, result);\n      result.push(node.value);\n    }\n    return result;\n  }\n  \n  // 레벨 순회 (BFS)\n  levelOrder() {\n    if (!this.root) return [];\n    \n    const result = [];\n    const queue = [this.root];\n    \n    while (queue.length > 0) {\n      const node = queue.shift();\n      result.push(node.value);\n      \n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n    \n    return result;\n  }\n}\n```\n\n## 힙 (Heap)\n\n완전 이진 트리 기반의 자료구조입니다.\n\n```javascript\nclass MaxHeap {\n  constructor() {\n    this.heap = [];\n  }\n  \n  // 부모 인덱스\n  getParentIndex(i) {\n    return Math.floor((i - 1) / 2);\n  }\n  \n  // 자식 인덱스\n  getLeftChildIndex(i) {\n    return 2 * i + 1;\n  }\n  \n  getRightChildIndex(i) {\n    return 2 * i + 2;\n  }\n  \n  // 삽입: O(log n)\n  insert(value) {\n    this.heap.push(value);\n    this.bubbleUp(this.heap.length - 1);\n  }\n  \n  bubbleUp(index) {\n    while (index > 0) {\n      const parentIndex = this.getParentIndex(index);\n      \n      if (this.heap[parentIndex] >= this.heap[index]) break;\n      \n      [this.heap[parentIndex], this.heap[index]] = \n        [this.heap[index], this.heap[parentIndex]];\n      \n      index = parentIndex;\n    }\n  }\n  \n  // 최대값 추출: O(log n)\n  extractMax() {\n    if (this.heap.length === 0) return null;\n    if (this.heap.length === 1) return this.heap.pop();\n    \n    const max = this.heap[0];\n    this.heap[0] = this.heap.pop();\n    this.bubbleDown(0);\n    \n    return max;\n  }\n  \n  bubbleDown(index) {\n    while (true) {\n      let largest = index;\n      const leftIndex = this.getLeftChildIndex(index);\n      const rightIndex = this.getRightChildIndex(index);\n      \n      if (leftIndex < this.heap.length && \n          this.heap[leftIndex] > this.heap[largest]) {\n        largest = leftIndex;\n      }\n      \n      if (rightIndex < this.heap.length && \n          this.heap[rightIndex] > this.heap[largest]) {\n        largest = rightIndex;\n      }\n      \n      if (largest === index) break;\n      \n      [this.heap[index], this.heap[largest]] = \n        [this.heap[largest], this.heap[index]];\n      \n      index = largest;\n    }\n  }\n  \n  // 최대값 확인: O(1)\n  peek() {\n    return this.heap[0] || null;\n  }\n}\n```\n\n## 그래프 (Graph)\n\n노드와 간선으로 연결된 자료구조입니다.\n\n```javascript\nclass Graph {\n  constructor() {\n    this.adjacencyList = {};\n  }\n  \n  // 정점 추가: O(1)\n  addVertex(vertex) {\n    if (!this.adjacencyList[vertex]) {\n      this.adjacencyList[vertex] = [];\n    }\n  }\n  \n  // 간선 추가: O(1)\n  addEdge(v1, v2) {\n    this.adjacencyList[v1].push(v2);\n    this.adjacencyList[v2].push(v1);  // 무방향 그래프\n  }\n  \n  // 간선 제거: O(E)\n  removeEdge(v1, v2) {\n    this.adjacencyList[v1] = this.adjacencyList[v1].filter(v => v !== v2);\n    this.adjacencyList[v2] = this.adjacencyList[v2].filter(v => v !== v1);\n  }\n  \n  // 정점 제거: O(V + E)\n  removeVertex(vertex) {\n    while (this.adjacencyList[vertex].length) {\n      const adjacentVertex = this.adjacencyList[vertex].pop();\n      this.removeEdge(vertex, adjacentVertex);\n    }\n    delete this.adjacencyList[vertex];\n  }\n  \n  // DFS\n  dfs(start) {\n    const result = [];\n    const visited = {};\n    \n    const traverse = (vertex) => {\n      if (!vertex) return;\n      \n      visited[vertex] = true;\n      result.push(vertex);\n      \n      for (const neighbor of this.adjacencyList[vertex]) {\n        if (!visited[neighbor]) {\n          traverse(neighbor);\n        }\n      }\n    };\n    \n    traverse(start);\n    return result;\n  }\n  \n  // BFS\n  bfs(start) {\n    const queue = [start];\n    const result = [];\n    const visited = { [start]: true };\n    \n    while (queue.length) {\n      const vertex = queue.shift();\n      result.push(vertex);\n      \n      for (const neighbor of this.adjacencyList[vertex]) {\n        if (!visited[neighbor]) {\n          visited[neighbor] = true;\n          queue.push(neighbor);\n        }\n      }\n    }\n    \n    return result;\n  }\n}\n```\n\n## 결론\n\n자료구조는 프로그래밍의 기초이자 핵심입니다.\n각 자료구조의 특성을 이해하고 상황에 맞게 선택하는 것이 중요합니다.\n시간 복잡도와 공간 복잡도를 고려하여 최적의 자료구조를 사용하면 효율적인 프로그램을 작성할 수 있습니다! 🚀\n\n"
  },
  {
    "id": "2025-10-11-algorithm-fundamentals",
    "slug": "2025-10-11-algorithm-fundamentals",
    "title": "알고리즘 기초부터 실전까지",
    "date": "2025-10-11",
    "category": "CS",
    "subcategory": "Algorithm",
    "tags": [
      "Algorithm",
      "Data Structure",
      "Problem Solving",
      "Coding Test"
    ],
    "excerpt": "코딩 테스트와 실무에 필요한 핵심 알고리즘들을 이해하고 활용하는 방법을 배웁니다.",
    "author": "Geon Lee",
    "content": "<h1>알고리즘 기초부터 실전까지</h1>\n<p>알고리즘은 문제를 효율적으로 해결하기 위한 단계적 절차입니다.</p>\n<h2>시간 복잡도 (Time Complexity)</h2>\n<p>알고리즘의 성능을 평가하는 가장 중요한 지표입니다.</p>\n<h3>Big-O 표기법</h3>\n<pre><code>O(1) &lt; O(log n) &lt; O(n) &lt; O(n log n) &lt; O(n²) &lt; O(2ⁿ) &lt; O(n!)\n</code></pre>\n<pre><code class=\"language-javascript\">// O(1) - 상수 시간\nfunction getFirst(arr) {\n  return arr[0];\n}\n\n// O(n) - 선형 시간\nfunction findMax(arr) {\n  let max = arr[0];\n  for (let i = 1; i &lt; arr.length; i++) {\n    if (arr[i] &gt; max) max = arr[i];\n  }\n  return max;\n}\n\n// O(n²) - 이차 시간\nfunction bubbleSort(arr) {\n  for (let i = 0; i &lt; arr.length; i++) {\n    for (let j = 0; j &lt; arr.length - 1; j++) {\n      if (arr[j] &gt; arr[j + 1]) {\n        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n      }\n    }\n  }\n  return arr;\n}\n\n// O(log n) - 로그 시간\nfunction binarySearch(arr, target) {\n  let left = 0, right = arr.length - 1;\n  \n  while (left &lt;= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid] === target) return mid;\n    if (arr[mid] &lt; target) left = mid + 1;\n    else right = mid - 1;\n  }\n  \n  return -1;\n}\n</code></pre>\n<h2>정렬 알고리즘</h2>\n<h3>퀵 정렬 (Quick Sort) - O(n log n)</h3>\n<pre><code class=\"language-javascript\">function quickSort(arr) {\n  if (arr.length &lt;= 1) return arr;\n  \n  const pivot = arr[Math.floor(arr.length / 2)];\n  const left = arr.filter(x =&gt; x &lt; pivot);\n  const middle = arr.filter(x =&gt; x === pivot);\n  const right = arr.filter(x =&gt; x &gt; pivot);\n  \n  return [...quickSort(left), ...middle, ...quickSort(right)];\n}\n\n// 최적화된 in-place 버전\nfunction quickSortInPlace(arr, low = 0, high = arr.length - 1) {\n  if (low &lt; high) {\n    const pi = partition(arr, low, high);\n    quickSortInPlace(arr, low, pi - 1);\n    quickSortInPlace(arr, pi + 1, high);\n  }\n  return arr;\n}\n\nfunction partition(arr, low, high) {\n  const pivot = arr[high];\n  let i = low - 1;\n  \n  for (let j = low; j &lt; high; j++) {\n    if (arr[j] &lt; pivot) {\n      i++;\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n  }\n  \n  [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];\n  return i + 1;\n}\n</code></pre>\n<h3>병합 정렬 (Merge Sort) - O(n log n)</h3>\n<pre><code class=\"language-javascript\">function mergeSort(arr) {\n  if (arr.length &lt;= 1) return arr;\n  \n  const mid = Math.floor(arr.length / 2);\n  const left = mergeSort(arr.slice(0, mid));\n  const right = mergeSort(arr.slice(mid));\n  \n  return merge(left, right);\n}\n\nfunction merge(left, right) {\n  const result = [];\n  let i = 0, j = 0;\n  \n  while (i &lt; left.length &amp;&amp; j &lt; right.length) {\n    if (left[i] &lt; right[j]) {\n      result.push(left[i++]);\n    } else {\n      result.push(right[j++]);\n    }\n  }\n  \n  return result.concat(left.slice(i), right.slice(j));\n}\n</code></pre>\n<h2>탐색 알고리즘</h2>\n<h3>이진 탐색 (Binary Search)</h3>\n<pre><code class=\"language-javascript\">// 반복문 버전\nfunction binarySearch(arr, target) {\n  let left = 0;\n  let right = arr.length - 1;\n  \n  while (left &lt;= right) {\n    const mid = Math.floor((left + right) / 2);\n    \n    if (arr[mid] === target) {\n      return mid;\n    } else if (arr[mid] &lt; target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  \n  return -1;\n}\n\n// 재귀 버전\nfunction binarySearchRecursive(arr, target, left = 0, right = arr.length - 1) {\n  if (left &gt; right) return -1;\n  \n  const mid = Math.floor((left + right) / 2);\n  \n  if (arr[mid] === target) return mid;\n  if (arr[mid] &lt; target) {\n    return binarySearchRecursive(arr, target, mid + 1, right);\n  }\n  return binarySearchRecursive(arr, target, left, mid - 1);\n}\n\n// 하한/상한 찾기\nfunction lowerBound(arr, target) {\n  let left = 0, right = arr.length;\n  \n  while (left &lt; right) {\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid] &lt; target) {\n      left = mid + 1;\n    } else {\n      right = mid;\n    }\n  }\n  \n  return left;\n}\n</code></pre>\n<h3>BFS (너비 우선 탐색)</h3>\n<pre><code class=\"language-javascript\">function bfs(graph, start) {\n  const visited = new Set();\n  const queue = [start];\n  const result = [];\n  \n  visited.add(start);\n  \n  while (queue.length &gt; 0) {\n    const node = queue.shift();\n    result.push(node);\n    \n    for (const neighbor of graph[node]) {\n      if (!visited.has(neighbor)) {\n        visited.add(neighbor);\n        queue.push(neighbor);\n      }\n    }\n  }\n  \n  return result;\n}\n\n// 최단 거리 찾기\nfunction shortestPath(graph, start, end) {\n  const queue = [[start, [start]]];\n  const visited = new Set([start]);\n  \n  while (queue.length &gt; 0) {\n    const [node, path] = queue.shift();\n    \n    if (node === end) {\n      return path;\n    }\n    \n    for (const neighbor of graph[node]) {\n      if (!visited.has(neighbor)) {\n        visited.add(neighbor);\n        queue.push([neighbor, [...path, neighbor]]);\n      }\n    }\n  }\n  \n  return null;\n}\n</code></pre>\n<h3>DFS (깊이 우선 탐색)</h3>\n<pre><code class=\"language-javascript\">// 재귀 버전\nfunction dfs(graph, node, visited = new Set(), result = []) {\n  visited.add(node);\n  result.push(node);\n  \n  for (const neighbor of graph[node]) {\n    if (!visited.has(neighbor)) {\n      dfs(graph, neighbor, visited, result);\n    }\n  }\n  \n  return result;\n}\n\n// 반복문 버전 (스택 사용)\nfunction dfsIterative(graph, start) {\n  const visited = new Set();\n  const stack = [start];\n  const result = [];\n  \n  while (stack.length &gt; 0) {\n    const node = stack.pop();\n    \n    if (!visited.has(node)) {\n      visited.add(node);\n      result.push(node);\n      \n      // 역순으로 추가 (먼저 탐색할 노드를 나중에 push)\n      for (let i = graph[node].length - 1; i &gt;= 0; i--) {\n        stack.push(graph[node][i]);\n      }\n    }\n  }\n  \n  return result;\n}\n</code></pre>\n<h2>동적 프로그래밍 (Dynamic Programming)</h2>\n<h3>피보나치 수열</h3>\n<pre><code class=\"language-javascript\">// ❌ 나쁜 예: O(2ⁿ)\nfunction fibonacci(n) {\n  if (n &lt;= 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n// ✅ 메모이제이션: O(n)\nfunction fibonacciMemo(n, memo = {}) {\n  if (n &lt;= 1) return n;\n  if (memo[n]) return memo[n];\n  \n  memo[n] = fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo);\n  return memo[n];\n}\n\n// ✅ 타뷸레이션 (Bottom-up): O(n)\nfunction fibonacciTab(n) {\n  if (n &lt;= 1) return n;\n  \n  const dp = [0, 1];\n  for (let i = 2; i &lt;= n; i++) {\n    dp[i] = dp[i - 1] + dp[i - 2];\n  }\n  \n  return dp[n];\n}\n\n// ✅ 공간 최적화: O(1)\nfunction fibonacciOptimized(n) {\n  if (n &lt;= 1) return n;\n  \n  let prev = 0, curr = 1;\n  for (let i = 2; i &lt;= n; i++) {\n    [prev, curr] = [curr, prev + curr];\n  }\n  \n  return curr;\n}\n</code></pre>\n<h3>배낭 문제 (Knapsack Problem)</h3>\n<pre><code class=\"language-javascript\">function knapsack(items, capacity) {\n  const n = items.length;\n  const dp = Array(n + 1).fill(0).map(() =&gt; Array(capacity + 1).fill(0));\n  \n  for (let i = 1; i &lt;= n; i++) {\n    const { weight, value } = items[i - 1];\n    \n    for (let w = 0; w &lt;= capacity; w++) {\n      if (weight &lt;= w) {\n        dp[i][w] = Math.max(\n          dp[i - 1][w],              // 현재 아이템 제외\n          dp[i - 1][w - weight] + value  // 현재 아이템 포함\n        );\n      } else {\n        dp[i][w] = dp[i - 1][w];\n      }\n    }\n  }\n  \n  return dp[n][capacity];\n}\n\n// 선택된 아이템 추적\nfunction knapsackWithItems(items, capacity) {\n  const n = items.length;\n  const dp = Array(n + 1).fill(0).map(() =&gt; Array(capacity + 1).fill(0));\n  \n  // DP 테이블 채우기\n  for (let i = 1; i &lt;= n; i++) {\n    const { weight, value } = items[i - 1];\n    for (let w = 0; w &lt;= capacity; w++) {\n      if (weight &lt;= w) {\n        dp[i][w] = Math.max(\n          dp[i - 1][w],\n          dp[i - 1][w - weight] + value\n        );\n      } else {\n        dp[i][w] = dp[i - 1][w];\n      }\n    }\n  }\n  \n  // 선택된 아이템 찾기\n  const selected = [];\n  let w = capacity;\n  for (let i = n; i &gt; 0; i--) {\n    if (dp[i][w] !== dp[i - 1][w]) {\n      selected.push(items[i - 1]);\n      w -= items[i - 1].weight;\n    }\n  }\n  \n  return { maxValue: dp[n][capacity], items: selected };\n}\n</code></pre>\n<h2>그리디 알고리즘</h2>\n<h3>동전 교환 문제</h3>\n<pre><code class=\"language-javascript\">function coinChange(coins, amount) {\n  coins.sort((a, b) =&gt; b - a);  // 큰 동전부터\n  \n  let count = 0;\n  for (const coin of coins) {\n    if (amount &gt;= coin) {\n      const use = Math.floor(amount / coin);\n      count += use;\n      amount -= coin * use;\n    }\n  }\n  \n  return amount === 0 ? count : -1;\n}\n</code></pre>\n<h3>활동 선택 문제</h3>\n<pre><code class=\"language-javascript\">function activitySelection(activities) {\n  // 종료 시간 기준 정렬\n  activities.sort((a, b) =&gt; a.end - b.end);\n  \n  const selected = [activities[0]];\n  let lastEnd = activities[0].end;\n  \n  for (let i = 1; i &lt; activities.length; i++) {\n    if (activities[i].start &gt;= lastEnd) {\n      selected.push(activities[i]);\n      lastEnd = activities[i].end;\n    }\n  }\n  \n  return selected;\n}\n</code></pre>\n<h2>실전 문제 패턴</h2>\n<h3>투 포인터 (Two Pointers)</h3>\n<pre><code class=\"language-javascript\">// 정렬된 배열에서 합이 target인 두 수 찾기\nfunction twoSum(arr, target) {\n  let left = 0, right = arr.length - 1;\n  \n  while (left &lt; right) {\n    const sum = arr[left] + arr[right];\n    if (sum === target) {\n      return [left, right];\n    } else if (sum &lt; target) {\n      left++;\n    } else {\n      right--;\n    }\n  }\n  \n  return null;\n}\n</code></pre>\n<h3>슬라이딩 윈도우 (Sliding Window)</h3>\n<pre><code class=\"language-javascript\">// 크기 k인 부분 배열의 최대 합\nfunction maxSubarraySum(arr, k) {\n  let maxSum = 0;\n  let windowSum = 0;\n  \n  // 첫 윈도우\n  for (let i = 0; i &lt; k; i++) {\n    windowSum += arr[i];\n  }\n  maxSum = windowSum;\n  \n  // 슬라이딩\n  for (let i = k; i &lt; arr.length; i++) {\n    windowSum = windowSum - arr[i - k] + arr[i];\n    maxSum = Math.max(maxSum, windowSum);\n  }\n  \n  return maxSum;\n}\n</code></pre>\n<h3>백트래킹 (Backtracking)</h3>\n<pre><code class=\"language-javascript\">// N-Queens 문제\nfunction solveNQueens(n) {\n  const result = [];\n  const board = Array(n).fill(0).map(() =&gt; Array(n).fill(&#39;.&#39;));\n  \n  function isSafe(row, col) {\n    // 같은 열 확인\n    for (let i = 0; i &lt; row; i++) {\n      if (board[i][col] === &#39;Q&#39;) return false;\n    }\n    \n    // 대각선 확인\n    for (let i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) {\n      if (board[i][j] === &#39;Q&#39;) return false;\n    }\n    for (let i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) {\n      if (board[i][j] === &#39;Q&#39;) return false;\n    }\n    \n    return true;\n  }\n  \n  function backtrack(row) {\n    if (row === n) {\n      result.push(board.map(r =&gt; r.join(&#39;&#39;)));\n      return;\n    }\n    \n    for (let col = 0; col &lt; n; col++) {\n      if (isSafe(row, col)) {\n        board[row][col] = &#39;Q&#39;;\n        backtrack(row + 1);\n        board[row][col] = &#39;.&#39;;  // 백트래킹\n      }\n    }\n  }\n  \n  backtrack(0);\n  return result;\n}\n</code></pre>\n<h2>결론</h2>\n<p>알고리즘은 문제 해결 능력의 핵심입니다.<br>기본 알고리즘을 이해하고 다양한 문제에 적용하는 연습이 중요합니다.<br>코딩 테스트뿐만 아니라 실무에서도 효율적인 코드를 작성하는 데 필수적입니다! 🚀</p>\n",
    "rawContent": "\n# 알고리즘 기초부터 실전까지\n\n알고리즘은 문제를 효율적으로 해결하기 위한 단계적 절차입니다.\n\n## 시간 복잡도 (Time Complexity)\n\n알고리즘의 성능을 평가하는 가장 중요한 지표입니다.\n\n### Big-O 표기법\n\n```\nO(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!)\n```\n\n```javascript\n// O(1) - 상수 시간\nfunction getFirst(arr) {\n  return arr[0];\n}\n\n// O(n) - 선형 시간\nfunction findMax(arr) {\n  let max = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > max) max = arr[i];\n  }\n  return max;\n}\n\n// O(n²) - 이차 시간\nfunction bubbleSort(arr) {\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr.length - 1; j++) {\n      if (arr[j] > arr[j + 1]) {\n        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n      }\n    }\n  }\n  return arr;\n}\n\n// O(log n) - 로그 시간\nfunction binarySearch(arr, target) {\n  let left = 0, right = arr.length - 1;\n  \n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid] === target) return mid;\n    if (arr[mid] < target) left = mid + 1;\n    else right = mid - 1;\n  }\n  \n  return -1;\n}\n```\n\n## 정렬 알고리즘\n\n### 퀵 정렬 (Quick Sort) - O(n log n)\n\n```javascript\nfunction quickSort(arr) {\n  if (arr.length <= 1) return arr;\n  \n  const pivot = arr[Math.floor(arr.length / 2)];\n  const left = arr.filter(x => x < pivot);\n  const middle = arr.filter(x => x === pivot);\n  const right = arr.filter(x => x > pivot);\n  \n  return [...quickSort(left), ...middle, ...quickSort(right)];\n}\n\n// 최적화된 in-place 버전\nfunction quickSortInPlace(arr, low = 0, high = arr.length - 1) {\n  if (low < high) {\n    const pi = partition(arr, low, high);\n    quickSortInPlace(arr, low, pi - 1);\n    quickSortInPlace(arr, pi + 1, high);\n  }\n  return arr;\n}\n\nfunction partition(arr, low, high) {\n  const pivot = arr[high];\n  let i = low - 1;\n  \n  for (let j = low; j < high; j++) {\n    if (arr[j] < pivot) {\n      i++;\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n  }\n  \n  [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];\n  return i + 1;\n}\n```\n\n### 병합 정렬 (Merge Sort) - O(n log n)\n\n```javascript\nfunction mergeSort(arr) {\n  if (arr.length <= 1) return arr;\n  \n  const mid = Math.floor(arr.length / 2);\n  const left = mergeSort(arr.slice(0, mid));\n  const right = mergeSort(arr.slice(mid));\n  \n  return merge(left, right);\n}\n\nfunction merge(left, right) {\n  const result = [];\n  let i = 0, j = 0;\n  \n  while (i < left.length && j < right.length) {\n    if (left[i] < right[j]) {\n      result.push(left[i++]);\n    } else {\n      result.push(right[j++]);\n    }\n  }\n  \n  return result.concat(left.slice(i), right.slice(j));\n}\n```\n\n## 탐색 알고리즘\n\n### 이진 탐색 (Binary Search)\n\n```javascript\n// 반복문 버전\nfunction binarySearch(arr, target) {\n  let left = 0;\n  let right = arr.length - 1;\n  \n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    \n    if (arr[mid] === target) {\n      return mid;\n    } else if (arr[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  \n  return -1;\n}\n\n// 재귀 버전\nfunction binarySearchRecursive(arr, target, left = 0, right = arr.length - 1) {\n  if (left > right) return -1;\n  \n  const mid = Math.floor((left + right) / 2);\n  \n  if (arr[mid] === target) return mid;\n  if (arr[mid] < target) {\n    return binarySearchRecursive(arr, target, mid + 1, right);\n  }\n  return binarySearchRecursive(arr, target, left, mid - 1);\n}\n\n// 하한/상한 찾기\nfunction lowerBound(arr, target) {\n  let left = 0, right = arr.length;\n  \n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid;\n    }\n  }\n  \n  return left;\n}\n```\n\n### BFS (너비 우선 탐색)\n\n```javascript\nfunction bfs(graph, start) {\n  const visited = new Set();\n  const queue = [start];\n  const result = [];\n  \n  visited.add(start);\n  \n  while (queue.length > 0) {\n    const node = queue.shift();\n    result.push(node);\n    \n    for (const neighbor of graph[node]) {\n      if (!visited.has(neighbor)) {\n        visited.add(neighbor);\n        queue.push(neighbor);\n      }\n    }\n  }\n  \n  return result;\n}\n\n// 최단 거리 찾기\nfunction shortestPath(graph, start, end) {\n  const queue = [[start, [start]]];\n  const visited = new Set([start]);\n  \n  while (queue.length > 0) {\n    const [node, path] = queue.shift();\n    \n    if (node === end) {\n      return path;\n    }\n    \n    for (const neighbor of graph[node]) {\n      if (!visited.has(neighbor)) {\n        visited.add(neighbor);\n        queue.push([neighbor, [...path, neighbor]]);\n      }\n    }\n  }\n  \n  return null;\n}\n```\n\n### DFS (깊이 우선 탐색)\n\n```javascript\n// 재귀 버전\nfunction dfs(graph, node, visited = new Set(), result = []) {\n  visited.add(node);\n  result.push(node);\n  \n  for (const neighbor of graph[node]) {\n    if (!visited.has(neighbor)) {\n      dfs(graph, neighbor, visited, result);\n    }\n  }\n  \n  return result;\n}\n\n// 반복문 버전 (스택 사용)\nfunction dfsIterative(graph, start) {\n  const visited = new Set();\n  const stack = [start];\n  const result = [];\n  \n  while (stack.length > 0) {\n    const node = stack.pop();\n    \n    if (!visited.has(node)) {\n      visited.add(node);\n      result.push(node);\n      \n      // 역순으로 추가 (먼저 탐색할 노드를 나중에 push)\n      for (let i = graph[node].length - 1; i >= 0; i--) {\n        stack.push(graph[node][i]);\n      }\n    }\n  }\n  \n  return result;\n}\n```\n\n## 동적 프로그래밍 (Dynamic Programming)\n\n### 피보나치 수열\n\n```javascript\n// ❌ 나쁜 예: O(2ⁿ)\nfunction fibonacci(n) {\n  if (n <= 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n// ✅ 메모이제이션: O(n)\nfunction fibonacciMemo(n, memo = {}) {\n  if (n <= 1) return n;\n  if (memo[n]) return memo[n];\n  \n  memo[n] = fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo);\n  return memo[n];\n}\n\n// ✅ 타뷸레이션 (Bottom-up): O(n)\nfunction fibonacciTab(n) {\n  if (n <= 1) return n;\n  \n  const dp = [0, 1];\n  for (let i = 2; i <= n; i++) {\n    dp[i] = dp[i - 1] + dp[i - 2];\n  }\n  \n  return dp[n];\n}\n\n// ✅ 공간 최적화: O(1)\nfunction fibonacciOptimized(n) {\n  if (n <= 1) return n;\n  \n  let prev = 0, curr = 1;\n  for (let i = 2; i <= n; i++) {\n    [prev, curr] = [curr, prev + curr];\n  }\n  \n  return curr;\n}\n```\n\n### 배낭 문제 (Knapsack Problem)\n\n```javascript\nfunction knapsack(items, capacity) {\n  const n = items.length;\n  const dp = Array(n + 1).fill(0).map(() => Array(capacity + 1).fill(0));\n  \n  for (let i = 1; i <= n; i++) {\n    const { weight, value } = items[i - 1];\n    \n    for (let w = 0; w <= capacity; w++) {\n      if (weight <= w) {\n        dp[i][w] = Math.max(\n          dp[i - 1][w],              // 현재 아이템 제외\n          dp[i - 1][w - weight] + value  // 현재 아이템 포함\n        );\n      } else {\n        dp[i][w] = dp[i - 1][w];\n      }\n    }\n  }\n  \n  return dp[n][capacity];\n}\n\n// 선택된 아이템 추적\nfunction knapsackWithItems(items, capacity) {\n  const n = items.length;\n  const dp = Array(n + 1).fill(0).map(() => Array(capacity + 1).fill(0));\n  \n  // DP 테이블 채우기\n  for (let i = 1; i <= n; i++) {\n    const { weight, value } = items[i - 1];\n    for (let w = 0; w <= capacity; w++) {\n      if (weight <= w) {\n        dp[i][w] = Math.max(\n          dp[i - 1][w],\n          dp[i - 1][w - weight] + value\n        );\n      } else {\n        dp[i][w] = dp[i - 1][w];\n      }\n    }\n  }\n  \n  // 선택된 아이템 찾기\n  const selected = [];\n  let w = capacity;\n  for (let i = n; i > 0; i--) {\n    if (dp[i][w] !== dp[i - 1][w]) {\n      selected.push(items[i - 1]);\n      w -= items[i - 1].weight;\n    }\n  }\n  \n  return { maxValue: dp[n][capacity], items: selected };\n}\n```\n\n## 그리디 알고리즘\n\n### 동전 교환 문제\n\n```javascript\nfunction coinChange(coins, amount) {\n  coins.sort((a, b) => b - a);  // 큰 동전부터\n  \n  let count = 0;\n  for (const coin of coins) {\n    if (amount >= coin) {\n      const use = Math.floor(amount / coin);\n      count += use;\n      amount -= coin * use;\n    }\n  }\n  \n  return amount === 0 ? count : -1;\n}\n```\n\n### 활동 선택 문제\n\n```javascript\nfunction activitySelection(activities) {\n  // 종료 시간 기준 정렬\n  activities.sort((a, b) => a.end - b.end);\n  \n  const selected = [activities[0]];\n  let lastEnd = activities[0].end;\n  \n  for (let i = 1; i < activities.length; i++) {\n    if (activities[i].start >= lastEnd) {\n      selected.push(activities[i]);\n      lastEnd = activities[i].end;\n    }\n  }\n  \n  return selected;\n}\n```\n\n## 실전 문제 패턴\n\n### 투 포인터 (Two Pointers)\n\n```javascript\n// 정렬된 배열에서 합이 target인 두 수 찾기\nfunction twoSum(arr, target) {\n  let left = 0, right = arr.length - 1;\n  \n  while (left < right) {\n    const sum = arr[left] + arr[right];\n    if (sum === target) {\n      return [left, right];\n    } else if (sum < target) {\n      left++;\n    } else {\n      right--;\n    }\n  }\n  \n  return null;\n}\n```\n\n### 슬라이딩 윈도우 (Sliding Window)\n\n```javascript\n// 크기 k인 부분 배열의 최대 합\nfunction maxSubarraySum(arr, k) {\n  let maxSum = 0;\n  let windowSum = 0;\n  \n  // 첫 윈도우\n  for (let i = 0; i < k; i++) {\n    windowSum += arr[i];\n  }\n  maxSum = windowSum;\n  \n  // 슬라이딩\n  for (let i = k; i < arr.length; i++) {\n    windowSum = windowSum - arr[i - k] + arr[i];\n    maxSum = Math.max(maxSum, windowSum);\n  }\n  \n  return maxSum;\n}\n```\n\n### 백트래킹 (Backtracking)\n\n```javascript\n// N-Queens 문제\nfunction solveNQueens(n) {\n  const result = [];\n  const board = Array(n).fill(0).map(() => Array(n).fill('.'));\n  \n  function isSafe(row, col) {\n    // 같은 열 확인\n    for (let i = 0; i < row; i++) {\n      if (board[i][col] === 'Q') return false;\n    }\n    \n    // 대각선 확인\n    for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n      if (board[i][j] === 'Q') return false;\n    }\n    for (let i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\n      if (board[i][j] === 'Q') return false;\n    }\n    \n    return true;\n  }\n  \n  function backtrack(row) {\n    if (row === n) {\n      result.push(board.map(r => r.join('')));\n      return;\n    }\n    \n    for (let col = 0; col < n; col++) {\n      if (isSafe(row, col)) {\n        board[row][col] = 'Q';\n        backtrack(row + 1);\n        board[row][col] = '.';  // 백트래킹\n      }\n    }\n  }\n  \n  backtrack(0);\n  return result;\n}\n```\n\n## 결론\n\n알고리즘은 문제 해결 능력의 핵심입니다.\n기본 알고리즘을 이해하고 다양한 문제에 적용하는 연습이 중요합니다.\n코딩 테스트뿐만 아니라 실무에서도 효율적인 코드를 작성하는 데 필수적입니다! 🚀\n\n"
  },
  {
    "id": "2025-10-10-kafka-event-streaming",
    "slug": "2025-10-10-kafka-event-streaming",
    "title": "Apache Kafka 이벤트 스트리밍 입문",
    "date": "2025-10-10",
    "category": "Platform",
    "subcategory": "Event Streaming",
    "tags": [
      "Kafka",
      "Event Streaming",
      "Message Queue",
      "Architecture"
    ],
    "excerpt": "Apache Kafka를 활용한 이벤트 스트리밍 아키텍처의 기본 개념과 실전 활용법을 배웁니다.",
    "author": "Geon Lee",
    "content": "<h1>Apache Kafka 이벤트 스트리밍 입문</h1>\n<p>Apache Kafka는 대용량 실시간 데이터 스트리밍을 처리하는 분산 이벤트 스트리밍 플랫폼입니다.</p>\n<h2>Kafka란?</h2>\n<p>LinkedIn에서 개발한 오픈소스 분산 스트리밍 플랫폼으로, 높은 처리량과 낮은 지연시간을 제공합니다.</p>\n<h3>주요 특징</h3>\n<ul>\n<li>📊 <strong>높은 처리량</strong>: 초당 수백만 개의 메시지 처리</li>\n<li>💾 <strong>영속성</strong>: 메시지를 디스크에 저장</li>\n<li>🔄 <strong>확장성</strong>: 수평 확장 가능</li>\n<li>⚡ <strong>낮은 지연시간</strong>: 밀리초 단위 응답</li>\n<li>🔁 <strong>복제</strong>: 데이터 복제로 내결함성 보장</li>\n</ul>\n<h2>핵심 개념</h2>\n<h3>Topic (토픽)</h3>\n<p>메시지가 저장되는 카테고리/피드입니다.</p>\n<pre><code class=\"language-bash\"># 토픽 생성\nkafka-topics --create \\\n  --topic orders \\\n  --bootstrap-server localhost:9092 \\\n  --partitions 3 \\\n  --replication-factor 2\n</code></pre>\n<h3>Partition (파티션)</h3>\n<p>토픽을 분할하여 병렬 처리를 가능하게 합니다.</p>\n<pre><code>Topic: orders\n├── Partition 0: [msg1, msg4, msg7, ...]\n├── Partition 1: [msg2, msg5, msg8, ...]\n└── Partition 2: [msg3, msg6, msg9, ...]\n</code></pre>\n<h3>Producer (프로듀서)</h3>\n<p>메시지를 Kafka에 발행하는 애플리케이션입니다.</p>\n<pre><code class=\"language-javascript\">// Node.js 프로듀서\nconst { Kafka } = require(&#39;kafkajs&#39;);\n\nconst kafka = new Kafka({\n  clientId: &#39;my-app&#39;,\n  brokers: [&#39;localhost:9092&#39;]\n});\n\nconst producer = kafka.producer();\n\nasync function sendMessage() {\n  await producer.connect();\n  \n  await producer.send({\n    topic: &#39;orders&#39;,\n    messages: [\n      {\n        key: &#39;order-123&#39;,\n        value: JSON.stringify({\n          orderId: 123,\n          userId: 456,\n          amount: 99.99,\n          timestamp: new Date().toISOString()\n        })\n      }\n    ]\n  });\n  \n  await producer.disconnect();\n}\n</code></pre>\n<h3>Consumer (컨슈머)</h3>\n<p>Kafka로부터 메시지를 읽는 애플리케이션입니다.</p>\n<pre><code class=\"language-javascript\">const consumer = kafka.consumer({ groupId: &#39;order-service&#39; });\n\nasync function consumeMessages() {\n  await consumer.connect();\n  await consumer.subscribe({ topic: &#39;orders&#39;, fromBeginning: true });\n  \n  await consumer.run({\n    eachMessage: async ({ topic, partition, message }) =&gt; {\n      console.log({\n        topic,\n        partition,\n        offset: message.offset,\n        key: message.key?.toString(),\n        value: JSON.parse(message.value.toString())\n      });\n    }\n  });\n}\n</code></pre>\n<h3>Consumer Group (컨슈머 그룹)</h3>\n<p>여러 컨슈머가 하나의 그룹으로 메시지를 분산 처리합니다.</p>\n<pre><code>Consumer Group: order-service\n├── Consumer 1 → Partition 0\n├── Consumer 2 → Partition 1\n└── Consumer 3 → Partition 2\n</code></pre>\n<h2>메시지 전송 방식</h2>\n<h3>At Most Once (최대 한 번)</h3>\n<pre><code class=\"language-javascript\">producer.send({\n  topic: &#39;orders&#39;,\n  messages: [{ value: &#39;message&#39; }],\n  acks: 0  // 응답 기다리지 않음\n});\n</code></pre>\n<h3>At Least Once (최소 한 번)</h3>\n<pre><code class=\"language-javascript\">producer.send({\n  topic: &#39;orders&#39;,\n  messages: [{ value: &#39;message&#39; }],\n  acks: 1  // 리더 파티션만 확인\n});\n</code></pre>\n<h3>Exactly Once (정확히 한 번)</h3>\n<pre><code class=\"language-javascript\">const producer = kafka.producer({\n  idempotent: true,\n  transactionalId: &#39;my-transactional-id&#39;\n});\n\nawait producer.connect();\n\nconst transaction = await producer.transaction();\ntry {\n  await transaction.send({\n    topic: &#39;orders&#39;,\n    messages: [{ value: &#39;message&#39; }]\n  });\n  await transaction.commit();\n} catch (error) {\n  await transaction.abort();\n}\n</code></pre>\n<h2>실전 패턴</h2>\n<h3>1. 이벤트 소싱 (Event Sourcing)</h3>\n<pre><code class=\"language-javascript\">// 주문 이벤트 발행\nasync function createOrder(order) {\n  const events = [\n    {\n      type: &#39;OrderCreated&#39;,\n      data: order,\n      timestamp: new Date()\n    },\n    {\n      type: &#39;InventoryReserved&#39;,\n      data: { items: order.items },\n      timestamp: new Date()\n    },\n    {\n      type: &#39;PaymentProcessed&#39;,\n      data: { amount: order.total },\n      timestamp: new Date()\n    }\n  ];\n  \n  for (const event of events) {\n    await producer.send({\n      topic: &#39;order-events&#39;,\n      messages: [{\n        key: order.id,\n        value: JSON.stringify(event)\n      }]\n    });\n  }\n}\n</code></pre>\n<h3>2. CQRS (Command Query Responsibility Segregation)</h3>\n<pre><code class=\"language-javascript\">// Command (쓰기)\nawait producer.send({\n  topic: &#39;user-commands&#39;,\n  messages: [{\n    value: JSON.stringify({\n      command: &#39;UpdateUserProfile&#39;,\n      userId: 123,\n      data: { name: &#39;John&#39;, email: &#39;john@example.com&#39; }\n    })\n  }]\n});\n\n// Query (읽기) - 별도 Read Model\nconst user = await readModelDb.getUser(123);\n</code></pre>\n<h3>3. Change Data Capture (CDC)</h3>\n<pre><code class=\"language-javascript\">// Debezium을 사용한 DB 변경 감지\n// MySQL 변경사항이 Kafka로 자동 전송됨\n{\n  &quot;before&quot;: null,\n  &quot;after&quot;: {\n    &quot;id&quot;: 123,\n    &quot;name&quot;: &quot;John&quot;,\n    &quot;email&quot;: &quot;john@example.com&quot;\n  },\n  &quot;source&quot;: {\n    &quot;version&quot;: &quot;1.9.7.Final&quot;,\n    &quot;connector&quot;: &quot;mysql&quot;,\n    &quot;name&quot;: &quot;mydb&quot;,\n    &quot;table&quot;: &quot;users&quot;\n  },\n  &quot;op&quot;: &quot;c&quot;,  // c: create, u: update, d: delete\n  &quot;ts_ms&quot;: 1678901234567\n}\n</code></pre>\n<h3>4. 사가 패턴 (Saga Pattern)</h3>\n<pre><code class=\"language-javascript\">// 분산 트랜잭션 관리\nasync function processOrder(order) {\n  // 1. 주문 생성\n  await producer.send({\n    topic: &#39;order-saga&#39;,\n    messages: [{\n      value: JSON.stringify({\n        saga: &#39;OrderSaga&#39;,\n        step: &#39;CreateOrder&#39;,\n        data: order\n      })\n    }]\n  });\n  \n  // 각 마이크로서비스가 이벤트를 소비하고\n  // 다음 단계 이벤트를 발행\n}\n\n// Saga Orchestrator\nconsumer.run({\n  eachMessage: async ({ message }) =&gt; {\n    const event = JSON.parse(message.value);\n    \n    switch (event.step) {\n      case &#39;CreateOrder&#39;:\n        // 재고 확인 요청\n        await sendEvent(&#39;CheckInventory&#39;, event.data);\n        break;\n      case &#39;InventoryChecked&#39;:\n        // 결제 요청\n        await sendEvent(&#39;ProcessPayment&#39;, event.data);\n        break;\n      case &#39;PaymentProcessed&#39;:\n        // 배송 요청\n        await sendEvent(&#39;ArrangeShipping&#39;, event.data);\n        break;\n      // 실패 시 보상 트랜잭션\n      case &#39;PaymentFailed&#39;:\n        await sendEvent(&#39;ReleaseInventory&#39;, event.data);\n        break;\n    }\n  }\n});\n</code></pre>\n<h2>Kafka Streams</h2>\n<h3>스트림 처리</h3>\n<pre><code class=\"language-javascript\">const { KafkaStreams } = require(&#39;kafka-streams&#39;);\n\nconst config = {\n  kafkaHost: &#39;localhost:9092&#39;\n};\n\nconst streams = new KafkaStreams(config);\n\nconst stream = streams.getKStream(&#39;orders&#39;);\n\n// 필터링\nstream\n  .filter(message =&gt; {\n    const order = JSON.parse(message.value);\n    return order.amount &gt; 100;\n  })\n  .to(&#39;high-value-orders&#39;);\n\n// 변환\nstream\n  .map(message =&gt; {\n    const order = JSON.parse(message.value);\n    return {\n      ...message,\n      value: JSON.stringify({\n        orderId: order.id,\n        total: order.amount * 1.1  // 세금 포함\n      })\n    };\n  })\n  .to(&#39;processed-orders&#39;);\n\n// 집계\nstream\n  .groupByKey()\n  .reduce(\n    (acc, message) =&gt; {\n      const order = JSON.parse(message.value);\n      return {\n        count: acc.count + 1,\n        total: acc.total + order.amount\n      };\n    },\n    { count: 0, total: 0 }\n  )\n  .to(&#39;order-statistics&#39;);\n</code></pre>\n<h3>Windowing (윈도우 연산)</h3>\n<pre><code class=\"language-javascript\">stream\n  .window({\n    type: &#39;tumbling&#39;,\n    duration: 60000  // 1분\n  })\n  .groupByKey()\n  .count()\n  .to(&#39;orders-per-minute&#39;);\n</code></pre>\n<h2>모니터링 및 관리</h2>\n<h3>Kafka Manager / AKHQ</h3>\n<pre><code class=\"language-yaml\"># docker-compose.yml\nversion: &#39;3&#39;\nservices:\n  akhq:\n    image: tchiotludo/akhq\n    ports:\n      - &quot;8080:8080&quot;\n    environment:\n      AKHQ_CONFIGURATION: |\n        akhq:\n          connections:\n            kafka:\n              properties:\n                bootstrap.servers: &quot;kafka:9092&quot;\n</code></pre>\n<h3>Consumer Lag 모니터링</h3>\n<pre><code class=\"language-bash\"># Consumer Group의 Lag 확인\nkafka-consumer-groups --bootstrap-server localhost:9092 \\\n  --group order-service \\\n  --describe\n</code></pre>\n<h2>성능 최적화</h2>\n<h3>1. 배치 처리</h3>\n<pre><code class=\"language-javascript\">const producer = kafka.producer({\n  // 메시지를 모아서 한번에 전송\n  &#39;batch.size&#39;: 16384,\n  &#39;linger.ms&#39;: 10,\n  &#39;compression.type&#39;: &#39;snappy&#39;\n});\n</code></pre>\n<h3>2. 파티션 키 설정</h3>\n<pre><code class=\"language-javascript\">// 동일한 키는 같은 파티션으로 전송\nawait producer.send({\n  topic: &#39;orders&#39;,\n  messages: [{\n    key: order.userId.toString(),  // 사용자별로 순서 보장\n    value: JSON.stringify(order)\n  }]\n});\n</code></pre>\n<h3>3. 병렬 처리</h3>\n<pre><code class=\"language-javascript\">const consumer = kafka.consumer({\n  groupId: &#39;order-service&#39;,\n  // 여러 파티션을 병렬로 처리\n  maxInFlightRequests: 5\n});\n\nawait consumer.run({\n  eachBatchAutoResolve: false,\n  eachBatch: async ({\n    batch,\n    resolveOffset,\n    heartbeat\n  }) =&gt; {\n    for (const message of batch.messages) {\n      // 메시지 처리\n      await processMessage(message);\n      \n      // 오프셋 커밋\n      resolveOffset(message.offset);\n      \n      // 주기적으로 heartbeat\n      await heartbeat();\n    }\n  }\n});\n</code></pre>\n<h2>에러 처리</h2>\n<h3>Dead Letter Queue (DLQ)</h3>\n<pre><code class=\"language-javascript\">consumer.run({\n  eachMessage: async ({ topic, partition, message }) =&gt; {\n    try {\n      await processMessage(message);\n    } catch (error) {\n      console.error(&#39;Processing failed:&#39;, error);\n      \n      // DLQ로 전송\n      await producer.send({\n        topic: &#39;orders-dlq&#39;,\n        messages: [{\n          key: message.key,\n          value: message.value,\n          headers: {\n            &#39;original-topic&#39;: topic,\n            &#39;error-message&#39;: error.message,\n            &#39;retry-count&#39;: &#39;1&#39;\n          }\n        }]\n      });\n    }\n  }\n});\n</code></pre>\n<h3>Retry 전략</h3>\n<pre><code class=\"language-javascript\">async function processWithRetry(message, maxRetries = 3) {\n  for (let i = 0; i &lt; maxRetries; i++) {\n    try {\n      await processMessage(message);\n      return;\n    } catch (error) {\n      if (i === maxRetries - 1) {\n        // 최종 실패 시 DLQ로\n        await sendToDLQ(message, error);\n      } else {\n        // 지수 백오프\n        await sleep(Math.pow(2, i) * 1000);\n      }\n    }\n  }\n}\n</code></pre>\n<h2>결론</h2>\n<p>Apache Kafka는 대규모 이벤트 스트리밍을 위한 강력한 플랫폼입니다.<br>마이크로서비스 아키텍처에서 서비스 간 통신, 이벤트 소싱, 실시간 데이터 파이프라인 구축에 필수적인 도구입니다! 🚀</p>\n",
    "rawContent": "\n# Apache Kafka 이벤트 스트리밍 입문\n\nApache Kafka는 대용량 실시간 데이터 스트리밍을 처리하는 분산 이벤트 스트리밍 플랫폼입니다.\n\n## Kafka란?\n\nLinkedIn에서 개발한 오픈소스 분산 스트리밍 플랫폼으로, 높은 처리량과 낮은 지연시간을 제공합니다.\n\n### 주요 특징\n\n- 📊 **높은 처리량**: 초당 수백만 개의 메시지 처리\n- 💾 **영속성**: 메시지를 디스크에 저장\n- 🔄 **확장성**: 수평 확장 가능\n- ⚡ **낮은 지연시간**: 밀리초 단위 응답\n- 🔁 **복제**: 데이터 복제로 내결함성 보장\n\n## 핵심 개념\n\n### Topic (토픽)\n\n메시지가 저장되는 카테고리/피드입니다.\n\n```bash\n# 토픽 생성\nkafka-topics --create \\\n  --topic orders \\\n  --bootstrap-server localhost:9092 \\\n  --partitions 3 \\\n  --replication-factor 2\n```\n\n### Partition (파티션)\n\n토픽을 분할하여 병렬 처리를 가능하게 합니다.\n\n```\nTopic: orders\n├── Partition 0: [msg1, msg4, msg7, ...]\n├── Partition 1: [msg2, msg5, msg8, ...]\n└── Partition 2: [msg3, msg6, msg9, ...]\n```\n\n### Producer (프로듀서)\n\n메시지를 Kafka에 발행하는 애플리케이션입니다.\n\n```javascript\n// Node.js 프로듀서\nconst { Kafka } = require('kafkajs');\n\nconst kafka = new Kafka({\n  clientId: 'my-app',\n  brokers: ['localhost:9092']\n});\n\nconst producer = kafka.producer();\n\nasync function sendMessage() {\n  await producer.connect();\n  \n  await producer.send({\n    topic: 'orders',\n    messages: [\n      {\n        key: 'order-123',\n        value: JSON.stringify({\n          orderId: 123,\n          userId: 456,\n          amount: 99.99,\n          timestamp: new Date().toISOString()\n        })\n      }\n    ]\n  });\n  \n  await producer.disconnect();\n}\n```\n\n### Consumer (컨슈머)\n\nKafka로부터 메시지를 읽는 애플리케이션입니다.\n\n```javascript\nconst consumer = kafka.consumer({ groupId: 'order-service' });\n\nasync function consumeMessages() {\n  await consumer.connect();\n  await consumer.subscribe({ topic: 'orders', fromBeginning: true });\n  \n  await consumer.run({\n    eachMessage: async ({ topic, partition, message }) => {\n      console.log({\n        topic,\n        partition,\n        offset: message.offset,\n        key: message.key?.toString(),\n        value: JSON.parse(message.value.toString())\n      });\n    }\n  });\n}\n```\n\n### Consumer Group (컨슈머 그룹)\n\n여러 컨슈머가 하나의 그룹으로 메시지를 분산 처리합니다.\n\n```\nConsumer Group: order-service\n├── Consumer 1 → Partition 0\n├── Consumer 2 → Partition 1\n└── Consumer 3 → Partition 2\n```\n\n## 메시지 전송 방식\n\n### At Most Once (최대 한 번)\n\n```javascript\nproducer.send({\n  topic: 'orders',\n  messages: [{ value: 'message' }],\n  acks: 0  // 응답 기다리지 않음\n});\n```\n\n### At Least Once (최소 한 번)\n\n```javascript\nproducer.send({\n  topic: 'orders',\n  messages: [{ value: 'message' }],\n  acks: 1  // 리더 파티션만 확인\n});\n```\n\n### Exactly Once (정확히 한 번)\n\n```javascript\nconst producer = kafka.producer({\n  idempotent: true,\n  transactionalId: 'my-transactional-id'\n});\n\nawait producer.connect();\n\nconst transaction = await producer.transaction();\ntry {\n  await transaction.send({\n    topic: 'orders',\n    messages: [{ value: 'message' }]\n  });\n  await transaction.commit();\n} catch (error) {\n  await transaction.abort();\n}\n```\n\n## 실전 패턴\n\n### 1. 이벤트 소싱 (Event Sourcing)\n\n```javascript\n// 주문 이벤트 발행\nasync function createOrder(order) {\n  const events = [\n    {\n      type: 'OrderCreated',\n      data: order,\n      timestamp: new Date()\n    },\n    {\n      type: 'InventoryReserved',\n      data: { items: order.items },\n      timestamp: new Date()\n    },\n    {\n      type: 'PaymentProcessed',\n      data: { amount: order.total },\n      timestamp: new Date()\n    }\n  ];\n  \n  for (const event of events) {\n    await producer.send({\n      topic: 'order-events',\n      messages: [{\n        key: order.id,\n        value: JSON.stringify(event)\n      }]\n    });\n  }\n}\n```\n\n### 2. CQRS (Command Query Responsibility Segregation)\n\n```javascript\n// Command (쓰기)\nawait producer.send({\n  topic: 'user-commands',\n  messages: [{\n    value: JSON.stringify({\n      command: 'UpdateUserProfile',\n      userId: 123,\n      data: { name: 'John', email: 'john@example.com' }\n    })\n  }]\n});\n\n// Query (읽기) - 별도 Read Model\nconst user = await readModelDb.getUser(123);\n```\n\n### 3. Change Data Capture (CDC)\n\n```javascript\n// Debezium을 사용한 DB 변경 감지\n// MySQL 변경사항이 Kafka로 자동 전송됨\n{\n  \"before\": null,\n  \"after\": {\n    \"id\": 123,\n    \"name\": \"John\",\n    \"email\": \"john@example.com\"\n  },\n  \"source\": {\n    \"version\": \"1.9.7.Final\",\n    \"connector\": \"mysql\",\n    \"name\": \"mydb\",\n    \"table\": \"users\"\n  },\n  \"op\": \"c\",  // c: create, u: update, d: delete\n  \"ts_ms\": 1678901234567\n}\n```\n\n### 4. 사가 패턴 (Saga Pattern)\n\n```javascript\n// 분산 트랜잭션 관리\nasync function processOrder(order) {\n  // 1. 주문 생성\n  await producer.send({\n    topic: 'order-saga',\n    messages: [{\n      value: JSON.stringify({\n        saga: 'OrderSaga',\n        step: 'CreateOrder',\n        data: order\n      })\n    }]\n  });\n  \n  // 각 마이크로서비스가 이벤트를 소비하고\n  // 다음 단계 이벤트를 발행\n}\n\n// Saga Orchestrator\nconsumer.run({\n  eachMessage: async ({ message }) => {\n    const event = JSON.parse(message.value);\n    \n    switch (event.step) {\n      case 'CreateOrder':\n        // 재고 확인 요청\n        await sendEvent('CheckInventory', event.data);\n        break;\n      case 'InventoryChecked':\n        // 결제 요청\n        await sendEvent('ProcessPayment', event.data);\n        break;\n      case 'PaymentProcessed':\n        // 배송 요청\n        await sendEvent('ArrangeShipping', event.data);\n        break;\n      // 실패 시 보상 트랜잭션\n      case 'PaymentFailed':\n        await sendEvent('ReleaseInventory', event.data);\n        break;\n    }\n  }\n});\n```\n\n## Kafka Streams\n\n### 스트림 처리\n\n```javascript\nconst { KafkaStreams } = require('kafka-streams');\n\nconst config = {\n  kafkaHost: 'localhost:9092'\n};\n\nconst streams = new KafkaStreams(config);\n\nconst stream = streams.getKStream('orders');\n\n// 필터링\nstream\n  .filter(message => {\n    const order = JSON.parse(message.value);\n    return order.amount > 100;\n  })\n  .to('high-value-orders');\n\n// 변환\nstream\n  .map(message => {\n    const order = JSON.parse(message.value);\n    return {\n      ...message,\n      value: JSON.stringify({\n        orderId: order.id,\n        total: order.amount * 1.1  // 세금 포함\n      })\n    };\n  })\n  .to('processed-orders');\n\n// 집계\nstream\n  .groupByKey()\n  .reduce(\n    (acc, message) => {\n      const order = JSON.parse(message.value);\n      return {\n        count: acc.count + 1,\n        total: acc.total + order.amount\n      };\n    },\n    { count: 0, total: 0 }\n  )\n  .to('order-statistics');\n```\n\n### Windowing (윈도우 연산)\n\n```javascript\nstream\n  .window({\n    type: 'tumbling',\n    duration: 60000  // 1분\n  })\n  .groupByKey()\n  .count()\n  .to('orders-per-minute');\n```\n\n## 모니터링 및 관리\n\n### Kafka Manager / AKHQ\n\n```yaml\n# docker-compose.yml\nversion: '3'\nservices:\n  akhq:\n    image: tchiotludo/akhq\n    ports:\n      - \"8080:8080\"\n    environment:\n      AKHQ_CONFIGURATION: |\n        akhq:\n          connections:\n            kafka:\n              properties:\n                bootstrap.servers: \"kafka:9092\"\n```\n\n### Consumer Lag 모니터링\n\n```bash\n# Consumer Group의 Lag 확인\nkafka-consumer-groups --bootstrap-server localhost:9092 \\\n  --group order-service \\\n  --describe\n```\n\n## 성능 최적화\n\n### 1. 배치 처리\n\n```javascript\nconst producer = kafka.producer({\n  // 메시지를 모아서 한번에 전송\n  'batch.size': 16384,\n  'linger.ms': 10,\n  'compression.type': 'snappy'\n});\n```\n\n### 2. 파티션 키 설정\n\n```javascript\n// 동일한 키는 같은 파티션으로 전송\nawait producer.send({\n  topic: 'orders',\n  messages: [{\n    key: order.userId.toString(),  // 사용자별로 순서 보장\n    value: JSON.stringify(order)\n  }]\n});\n```\n\n### 3. 병렬 처리\n\n```javascript\nconst consumer = kafka.consumer({\n  groupId: 'order-service',\n  // 여러 파티션을 병렬로 처리\n  maxInFlightRequests: 5\n});\n\nawait consumer.run({\n  eachBatchAutoResolve: false,\n  eachBatch: async ({\n    batch,\n    resolveOffset,\n    heartbeat\n  }) => {\n    for (const message of batch.messages) {\n      // 메시지 처리\n      await processMessage(message);\n      \n      // 오프셋 커밋\n      resolveOffset(message.offset);\n      \n      // 주기적으로 heartbeat\n      await heartbeat();\n    }\n  }\n});\n```\n\n## 에러 처리\n\n### Dead Letter Queue (DLQ)\n\n```javascript\nconsumer.run({\n  eachMessage: async ({ topic, partition, message }) => {\n    try {\n      await processMessage(message);\n    } catch (error) {\n      console.error('Processing failed:', error);\n      \n      // DLQ로 전송\n      await producer.send({\n        topic: 'orders-dlq',\n        messages: [{\n          key: message.key,\n          value: message.value,\n          headers: {\n            'original-topic': topic,\n            'error-message': error.message,\n            'retry-count': '1'\n          }\n        }]\n      });\n    }\n  }\n});\n```\n\n### Retry 전략\n\n```javascript\nasync function processWithRetry(message, maxRetries = 3) {\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      await processMessage(message);\n      return;\n    } catch (error) {\n      if (i === maxRetries - 1) {\n        // 최종 실패 시 DLQ로\n        await sendToDLQ(message, error);\n      } else {\n        // 지수 백오프\n        await sleep(Math.pow(2, i) * 1000);\n      }\n    }\n  }\n}\n```\n\n## 결론\n\nApache Kafka는 대규모 이벤트 스트리밍을 위한 강력한 플랫폼입니다.\n마이크로서비스 아키텍처에서 서비스 간 통신, 이벤트 소싱, 실시간 데이터 파이프라인 구축에 필수적인 도구입니다! 🚀\n\n"
  },
  {
    "id": "2025-10-09-redis-caching-strategies",
    "slug": "2025-10-09-redis-caching-strategies",
    "title": "Redis 캐싱 전략 완벽 가이드",
    "date": "2025-10-09",
    "category": "Database",
    "subcategory": "Redis",
    "tags": [
      "Redis",
      "Cache",
      "Performance",
      "In-Memory"
    ],
    "excerpt": "Redis를 활용한 효과적인 캐싱 전략과 실전 패턴을 배워 애플리케이션 성능을 극대화합니다.",
    "author": "Geon Lee",
    "content": "<h1>Redis 캐싱 전략 완벽 가이드</h1>\n<p>Redis는 인메모리 데이터 구조 저장소로, 캐싱, 세션 관리, 실시간 분석 등에 널리 사용됩니다.</p>\n<h2>Redis란?</h2>\n<p><strong>REmote DIctionary Server</strong>의 약자로, 고성능 키-값 저장소입니다.</p>\n<h3>주요 특징</h3>\n<ul>\n<li>⚡ <strong>빠른 성능</strong>: 메모리 기반으로 마이크로초 단위 응답</li>\n<li>🔄 <strong>다양한 자료구조</strong>: String, List, Set, Hash, Sorted Set 등</li>\n<li>💾 <strong>영속성</strong>: 데이터를 디스크에 저장 가능</li>\n<li>🔁 <strong>복제</strong>: Master-Slave 복제 지원</li>\n<li>⚖️ <strong>확장성</strong>: Redis Cluster로 수평 확장</li>\n</ul>\n<h2>기본 명령어</h2>\n<h3>String 타입</h3>\n<pre><code class=\"language-bash\"># 저장\nSET user:1 &quot;John&quot;\nSET user:1 &quot;John&quot; EX 3600  # 1시간 TTL\n\n# 조회\nGET user:1\n\n# 증가/감소\nINCR counter\nDECR counter\nINCRBY counter 5\n\n# 여러 키 한번에\nMSET user:1 &quot;John&quot; user:2 &quot;Jane&quot;\nMGET user:1 user:2\n</code></pre>\n<h3>Hash 타입</h3>\n<pre><code class=\"language-bash\"># 사용자 객체 저장\nHSET user:1 name &quot;John&quot; age 30 email &quot;john@example.com&quot;\n\n# 특정 필드 조회\nHGET user:1 name\n\n# 전체 조회\nHGETALL user:1\n\n# 필드 존재 확인\nHEXISTS user:1 name\n</code></pre>\n<h3>List 타입</h3>\n<pre><code class=\"language-bash\"># 추가 (왼쪽/오른쪽)\nLPUSH queue &quot;task1&quot;\nRPUSH queue &quot;task2&quot;\n\n# 제거 및 반환\nLPOP queue\nRPOP queue\n\n# 범위 조회\nLRANGE queue 0 -1\n\n# 길이\nLLEN queue\n</code></pre>\n<h3>Set 타입</h3>\n<pre><code class=\"language-bash\"># 추가\nSADD tags &quot;javascript&quot; &quot;nodejs&quot; &quot;redis&quot;\n\n# 멤버 확인\nSISMEMBER tags &quot;javascript&quot;\n\n# 전체 조회\nSMEMBERS tags\n\n# 집합 연산\nSUNION tags1 tags2      # 합집합\nSINTER tags1 tags2      # 교집합\nSDIFF tags1 tags2       # 차집합\n</code></pre>\n<h3>Sorted Set 타입</h3>\n<pre><code class=\"language-bash\"># 추가 (스코어와 함께)\nZADD leaderboard 100 &quot;player1&quot;\nZADD leaderboard 200 &quot;player2&quot;\n\n# 순위 조회 (오름차순)\nZRANGE leaderboard 0 -1 WITHSCORES\n\n# 순위 조회 (내림차순)\nZREVRANGE leaderboard 0 9 WITHSCORES\n\n# 특정 멤버 스코어\nZSCORE leaderboard &quot;player1&quot;\n\n# 순위 (0부터 시작)\nZRANK leaderboard &quot;player1&quot;\n</code></pre>\n<h2>캐싱 전략</h2>\n<h3>1. Cache-Aside (Lazy Loading)</h3>\n<p>애플리케이션이 캐시를 직접 관리하는 패턴입니다.</p>\n<pre><code class=\"language-javascript\">async function getUser(id) {\n  const cacheKey = `user:${id}`;\n  \n  // 1. 캐시 확인\n  let user = await redis.get(cacheKey);\n  \n  if (user) {\n    return JSON.parse(user);\n  }\n  \n  // 2. DB 조회\n  user = await db.query(&#39;SELECT * FROM users WHERE id = ?&#39;, [id]);\n  \n  // 3. 캐시 저장\n  await redis.setex(cacheKey, 3600, JSON.stringify(user));\n  \n  return user;\n}\n</code></pre>\n<p><strong>장점</strong>: 필요한 데이터만 캐싱<br><strong>단점</strong>: 초기 요청은 느림 (Cache Miss)</p>\n<h3>2. Write-Through</h3>\n<p>데이터를 쓸 때 캐시와 DB를 동시에 업데이트합니다.</p>\n<pre><code class=\"language-javascript\">async function updateUser(id, data) {\n  const cacheKey = `user:${id}`;\n  \n  // 1. DB 업데이트\n  await db.query(&#39;UPDATE users SET ? WHERE id = ?&#39;, [data, id]);\n  \n  // 2. 캐시 업데이트\n  const user = await db.query(&#39;SELECT * FROM users WHERE id = ?&#39;, [id]);\n  await redis.setex(cacheKey, 3600, JSON.stringify(user));\n  \n  return user;\n}\n</code></pre>\n<p><strong>장점</strong>: 데이터 일관성 보장<br><strong>단점</strong>: 쓰기 성능 저하</p>\n<h3>3. Write-Behind (Write-Back)</h3>\n<p>캐시만 업데이트하고, DB는 비동기로 업데이트합니다.</p>\n<pre><code class=\"language-javascript\">async function updateUser(id, data) {\n  const cacheKey = `user:${id}`;\n  \n  // 1. 캐시 업데이트\n  const user = { ...data, id };\n  await redis.setex(cacheKey, 3600, JSON.stringify(user));\n  \n  // 2. DB 업데이트 작업 큐에 추가\n  await queue.add(&#39;updateUserDB&#39;, { id, data });\n  \n  return user;\n}\n</code></pre>\n<p><strong>장점</strong>: 빠른 쓰기 성능<br><strong>단점</strong>: 데이터 유실 가능성</p>\n<h3>4. Refresh-Ahead</h3>\n<p>만료 전에 미리 갱신하는 패턴입니다.</p>\n<pre><code class=\"language-javascript\">async function getUser(id) {\n  const cacheKey = `user:${id}`;\n  \n  let user = await redis.get(cacheKey);\n  const ttl = await redis.ttl(cacheKey);\n  \n  // TTL이 10분 미만이면 백그라운드에서 갱신\n  if (ttl &lt; 600) {\n    refreshUserCache(id);  // 비동기 실행\n  }\n  \n  if (user) {\n    return JSON.parse(user);\n  }\n  \n  // Cache Miss 시 동기 로딩\n  return await loadAndCacheUser(id);\n}\n</code></pre>\n<h2>캐시 무효화 전략</h2>\n<h3>1. TTL (Time To Live)</h3>\n<pre><code class=\"language-javascript\">// 1시간 후 자동 만료\nawait redis.setex(&#39;user:1&#39;, 3600, JSON.stringify(user));\n\n// 특정 시간에 만료\nconst expiresAt = new Date(&#39;2024-12-31 23:59:59&#39;);\nconst ttl = Math.floor((expiresAt - Date.now()) / 1000);\nawait redis.setex(&#39;promotion&#39;, ttl, data);\n</code></pre>\n<h3>2. 명시적 삭제</h3>\n<pre><code class=\"language-javascript\">// 단일 키 삭제\nawait redis.del(&#39;user:1&#39;);\n\n// 패턴 매칭 삭제\nconst keys = await redis.keys(&#39;user:*&#39;);\nif (keys.length &gt; 0) {\n  await redis.del(...keys);\n}\n\n// SCAN을 사용한 안전한 삭제\nlet cursor = &#39;0&#39;;\ndo {\n  const [newCursor, keys] = await redis.scan(\n    cursor, \n    &#39;MATCH&#39;, &#39;user:*&#39;, \n    &#39;COUNT&#39;, 100\n  );\n  cursor = newCursor;\n  if (keys.length &gt; 0) {\n    await redis.del(...keys);\n  }\n} while (cursor !== &#39;0&#39;);\n</code></pre>\n<h3>3. 태그 기반 무효화</h3>\n<pre><code class=\"language-javascript\">// 사용자와 관련된 모든 캐시에 태그 추가\nawait redis.sadd(&#39;tag:user:1&#39;, &#39;user:1:profile&#39;);\nawait redis.sadd(&#39;tag:user:1&#39;, &#39;user:1:orders&#39;);\nawait redis.sadd(&#39;tag:user:1&#39;, &#39;user:1:cart&#39;);\n\n// 태그로 한번에 무효화\nasync function invalidateUserCache(userId) {\n  const tag = `tag:user:${userId}`;\n  const keys = await redis.smembers(tag);\n  \n  if (keys.length &gt; 0) {\n    await redis.del(...keys);\n    await redis.del(tag);\n  }\n}\n</code></pre>\n<h2>실전 패턴</h2>\n<h3>1. 세션 관리</h3>\n<pre><code class=\"language-javascript\">// 세션 저장 (7일)\nawait redis.setex(\n  `session:${sessionId}`,\n  7 * 24 * 60 * 60,\n  JSON.stringify({\n    userId: 1,\n    username: &#39;john&#39;,\n    loginAt: new Date()\n  })\n);\n\n// 세션 조회\nconst session = await redis.get(`session:${sessionId}`);\n\n// 세션 갱신\nawait redis.expire(`session:${sessionId}`, 7 * 24 * 60 * 60);\n</code></pre>\n<h3>2. Rate Limiting</h3>\n<pre><code class=\"language-javascript\">async function checkRateLimit(userId, limit = 100, window = 60) {\n  const key = `rate_limit:${userId}`;\n  \n  // 현재 카운트 증가\n  const count = await redis.incr(key);\n  \n  // 첫 요청이면 TTL 설정\n  if (count === 1) {\n    await redis.expire(key, window);\n  }\n  \n  return {\n    allowed: count &lt;= limit,\n    remaining: Math.max(0, limit - count),\n    resetIn: await redis.ttl(key)\n  };\n}\n</code></pre>\n<h3>3. 리더보드</h3>\n<pre><code class=\"language-javascript\">// 점수 추가/업데이트\nawait redis.zadd(&#39;leaderboard:2024&#39;, score, userId);\n\n// 상위 10명\nconst top10 = await redis.zrevrange(&#39;leaderboard:2024&#39;, 0, 9, &#39;WITHSCORES&#39;);\n\n// 특정 사용자 순위\nconst rank = await redis.zrevrank(&#39;leaderboard:2024&#39;, userId);\n\n// 주변 순위 조회\nconst myRank = await redis.zrevrank(&#39;leaderboard:2024&#39;, userId);\nconst around = await redis.zrevrange(\n  &#39;leaderboard:2024&#39;,\n  Math.max(0, myRank - 5),\n  myRank + 5,\n  &#39;WITHSCORES&#39;\n);\n</code></pre>\n<h3>4. 분산 락</h3>\n<pre><code class=\"language-javascript\">async function acquireLock(lockKey, timeout = 10) {\n  const value = Date.now() + timeout * 1000;\n  \n  // NX: key가 없을 때만, PX: 밀리초 단위 TTL\n  const acquired = await redis.set(\n    lockKey,\n    value,\n    &#39;NX&#39;,\n    &#39;PX&#39;,\n    timeout * 1000\n  );\n  \n  return acquired === &#39;OK&#39;;\n}\n\nasync function releaseLock(lockKey) {\n  await redis.del(lockKey);\n}\n\n// 사용 예\nconst locked = await acquireLock(&#39;order:123&#39;);\nif (locked) {\n  try {\n    // 임계 영역 작업\n    await processOrder(123);\n  } finally {\n    await releaseLock(&#39;order:123&#39;);\n  }\n}\n</code></pre>\n<h3>5. Pub/Sub</h3>\n<pre><code class=\"language-javascript\">// Publisher\nawait redis.publish(&#39;notifications&#39;, JSON.stringify({\n  type: &#39;new_message&#39;,\n  userId: 123,\n  message: &#39;Hello!&#39;\n}));\n\n// Subscriber\nconst subscriber = redis.duplicate();\nawait subscriber.subscribe(&#39;notifications&#39;);\n\nsubscriber.on(&#39;message&#39;, (channel, message) =&gt; {\n  const data = JSON.parse(message);\n  console.log(&#39;Received:&#39;, data);\n});\n</code></pre>\n<h2>성능 최적화</h2>\n<h3>1. Pipeline</h3>\n<pre><code class=\"language-javascript\">// 여러 명령을 한번에 전송\nconst pipeline = redis.pipeline();\npipeline.set(&#39;key1&#39;, &#39;value1&#39;);\npipeline.set(&#39;key2&#39;, &#39;value2&#39;);\npipeline.get(&#39;key1&#39;);\nconst results = await pipeline.exec();\n</code></pre>\n<h3>2. 적절한 자료구조 선택</h3>\n<pre><code class=\"language-javascript\">// ❌ 나쁜 예: String으로 객체 저장\nawait redis.set(&#39;user:1&#39;, JSON.stringify({ name: &#39;John&#39;, age: 30 }));\n\n// ✅ 좋은 예: Hash 사용\nawait redis.hset(&#39;user:1&#39;, &#39;name&#39;, &#39;John&#39;, &#39;age&#39;, 30);\n</code></pre>\n<h3>3. 메모리 최적화</h3>\n<pre><code class=\"language-yaml\"># redis.conf\nmaxmemory 2gb\nmaxmemory-policy allkeys-lru  # LRU 정책으로 메모리 관리\n</code></pre>\n<h2>결론</h2>\n<p>Redis는 단순한 캐시를 넘어 세션, 큐, 실시간 분석 등 다양한 용도로 활용할 수 있는 강력한 도구입니다.<br>적절한 캐싱 전략과 자료구조를 선택하면 애플리케이션 성능을 획기적으로 향상시킬 수 있습니다! 🚀</p>\n",
    "rawContent": "\n# Redis 캐싱 전략 완벽 가이드\n\nRedis는 인메모리 데이터 구조 저장소로, 캐싱, 세션 관리, 실시간 분석 등에 널리 사용됩니다.\n\n## Redis란?\n\n**REmote DIctionary Server**의 약자로, 고성능 키-값 저장소입니다.\n\n### 주요 특징\n\n- ⚡ **빠른 성능**: 메모리 기반으로 마이크로초 단위 응답\n- 🔄 **다양한 자료구조**: String, List, Set, Hash, Sorted Set 등\n- 💾 **영속성**: 데이터를 디스크에 저장 가능\n- 🔁 **복제**: Master-Slave 복제 지원\n- ⚖️ **확장성**: Redis Cluster로 수평 확장\n\n## 기본 명령어\n\n### String 타입\n\n```bash\n# 저장\nSET user:1 \"John\"\nSET user:1 \"John\" EX 3600  # 1시간 TTL\n\n# 조회\nGET user:1\n\n# 증가/감소\nINCR counter\nDECR counter\nINCRBY counter 5\n\n# 여러 키 한번에\nMSET user:1 \"John\" user:2 \"Jane\"\nMGET user:1 user:2\n```\n\n### Hash 타입\n\n```bash\n# 사용자 객체 저장\nHSET user:1 name \"John\" age 30 email \"john@example.com\"\n\n# 특정 필드 조회\nHGET user:1 name\n\n# 전체 조회\nHGETALL user:1\n\n# 필드 존재 확인\nHEXISTS user:1 name\n```\n\n### List 타입\n\n```bash\n# 추가 (왼쪽/오른쪽)\nLPUSH queue \"task1\"\nRPUSH queue \"task2\"\n\n# 제거 및 반환\nLPOP queue\nRPOP queue\n\n# 범위 조회\nLRANGE queue 0 -1\n\n# 길이\nLLEN queue\n```\n\n### Set 타입\n\n```bash\n# 추가\nSADD tags \"javascript\" \"nodejs\" \"redis\"\n\n# 멤버 확인\nSISMEMBER tags \"javascript\"\n\n# 전체 조회\nSMEMBERS tags\n\n# 집합 연산\nSUNION tags1 tags2      # 합집합\nSINTER tags1 tags2      # 교집합\nSDIFF tags1 tags2       # 차집합\n```\n\n### Sorted Set 타입\n\n```bash\n# 추가 (스코어와 함께)\nZADD leaderboard 100 \"player1\"\nZADD leaderboard 200 \"player2\"\n\n# 순위 조회 (오름차순)\nZRANGE leaderboard 0 -1 WITHSCORES\n\n# 순위 조회 (내림차순)\nZREVRANGE leaderboard 0 9 WITHSCORES\n\n# 특정 멤버 스코어\nZSCORE leaderboard \"player1\"\n\n# 순위 (0부터 시작)\nZRANK leaderboard \"player1\"\n```\n\n## 캐싱 전략\n\n### 1. Cache-Aside (Lazy Loading)\n\n애플리케이션이 캐시를 직접 관리하는 패턴입니다.\n\n```javascript\nasync function getUser(id) {\n  const cacheKey = `user:${id}`;\n  \n  // 1. 캐시 확인\n  let user = await redis.get(cacheKey);\n  \n  if (user) {\n    return JSON.parse(user);\n  }\n  \n  // 2. DB 조회\n  user = await db.query('SELECT * FROM users WHERE id = ?', [id]);\n  \n  // 3. 캐시 저장\n  await redis.setex(cacheKey, 3600, JSON.stringify(user));\n  \n  return user;\n}\n```\n\n**장점**: 필요한 데이터만 캐싱  \n**단점**: 초기 요청은 느림 (Cache Miss)\n\n### 2. Write-Through\n\n데이터를 쓸 때 캐시와 DB를 동시에 업데이트합니다.\n\n```javascript\nasync function updateUser(id, data) {\n  const cacheKey = `user:${id}`;\n  \n  // 1. DB 업데이트\n  await db.query('UPDATE users SET ? WHERE id = ?', [data, id]);\n  \n  // 2. 캐시 업데이트\n  const user = await db.query('SELECT * FROM users WHERE id = ?', [id]);\n  await redis.setex(cacheKey, 3600, JSON.stringify(user));\n  \n  return user;\n}\n```\n\n**장점**: 데이터 일관성 보장  \n**단점**: 쓰기 성능 저하\n\n### 3. Write-Behind (Write-Back)\n\n캐시만 업데이트하고, DB는 비동기로 업데이트합니다.\n\n```javascript\nasync function updateUser(id, data) {\n  const cacheKey = `user:${id}`;\n  \n  // 1. 캐시 업데이트\n  const user = { ...data, id };\n  await redis.setex(cacheKey, 3600, JSON.stringify(user));\n  \n  // 2. DB 업데이트 작업 큐에 추가\n  await queue.add('updateUserDB', { id, data });\n  \n  return user;\n}\n```\n\n**장점**: 빠른 쓰기 성능  \n**단점**: 데이터 유실 가능성\n\n### 4. Refresh-Ahead\n\n만료 전에 미리 갱신하는 패턴입니다.\n\n```javascript\nasync function getUser(id) {\n  const cacheKey = `user:${id}`;\n  \n  let user = await redis.get(cacheKey);\n  const ttl = await redis.ttl(cacheKey);\n  \n  // TTL이 10분 미만이면 백그라운드에서 갱신\n  if (ttl < 600) {\n    refreshUserCache(id);  // 비동기 실행\n  }\n  \n  if (user) {\n    return JSON.parse(user);\n  }\n  \n  // Cache Miss 시 동기 로딩\n  return await loadAndCacheUser(id);\n}\n```\n\n## 캐시 무효화 전략\n\n### 1. TTL (Time To Live)\n\n```javascript\n// 1시간 후 자동 만료\nawait redis.setex('user:1', 3600, JSON.stringify(user));\n\n// 특정 시간에 만료\nconst expiresAt = new Date('2024-12-31 23:59:59');\nconst ttl = Math.floor((expiresAt - Date.now()) / 1000);\nawait redis.setex('promotion', ttl, data);\n```\n\n### 2. 명시적 삭제\n\n```javascript\n// 단일 키 삭제\nawait redis.del('user:1');\n\n// 패턴 매칭 삭제\nconst keys = await redis.keys('user:*');\nif (keys.length > 0) {\n  await redis.del(...keys);\n}\n\n// SCAN을 사용한 안전한 삭제\nlet cursor = '0';\ndo {\n  const [newCursor, keys] = await redis.scan(\n    cursor, \n    'MATCH', 'user:*', \n    'COUNT', 100\n  );\n  cursor = newCursor;\n  if (keys.length > 0) {\n    await redis.del(...keys);\n  }\n} while (cursor !== '0');\n```\n\n### 3. 태그 기반 무효화\n\n```javascript\n// 사용자와 관련된 모든 캐시에 태그 추가\nawait redis.sadd('tag:user:1', 'user:1:profile');\nawait redis.sadd('tag:user:1', 'user:1:orders');\nawait redis.sadd('tag:user:1', 'user:1:cart');\n\n// 태그로 한번에 무효화\nasync function invalidateUserCache(userId) {\n  const tag = `tag:user:${userId}`;\n  const keys = await redis.smembers(tag);\n  \n  if (keys.length > 0) {\n    await redis.del(...keys);\n    await redis.del(tag);\n  }\n}\n```\n\n## 실전 패턴\n\n### 1. 세션 관리\n\n```javascript\n// 세션 저장 (7일)\nawait redis.setex(\n  `session:${sessionId}`,\n  7 * 24 * 60 * 60,\n  JSON.stringify({\n    userId: 1,\n    username: 'john',\n    loginAt: new Date()\n  })\n);\n\n// 세션 조회\nconst session = await redis.get(`session:${sessionId}`);\n\n// 세션 갱신\nawait redis.expire(`session:${sessionId}`, 7 * 24 * 60 * 60);\n```\n\n### 2. Rate Limiting\n\n```javascript\nasync function checkRateLimit(userId, limit = 100, window = 60) {\n  const key = `rate_limit:${userId}`;\n  \n  // 현재 카운트 증가\n  const count = await redis.incr(key);\n  \n  // 첫 요청이면 TTL 설정\n  if (count === 1) {\n    await redis.expire(key, window);\n  }\n  \n  return {\n    allowed: count <= limit,\n    remaining: Math.max(0, limit - count),\n    resetIn: await redis.ttl(key)\n  };\n}\n```\n\n### 3. 리더보드\n\n```javascript\n// 점수 추가/업데이트\nawait redis.zadd('leaderboard:2024', score, userId);\n\n// 상위 10명\nconst top10 = await redis.zrevrange('leaderboard:2024', 0, 9, 'WITHSCORES');\n\n// 특정 사용자 순위\nconst rank = await redis.zrevrank('leaderboard:2024', userId);\n\n// 주변 순위 조회\nconst myRank = await redis.zrevrank('leaderboard:2024', userId);\nconst around = await redis.zrevrange(\n  'leaderboard:2024',\n  Math.max(0, myRank - 5),\n  myRank + 5,\n  'WITHSCORES'\n);\n```\n\n### 4. 분산 락\n\n```javascript\nasync function acquireLock(lockKey, timeout = 10) {\n  const value = Date.now() + timeout * 1000;\n  \n  // NX: key가 없을 때만, PX: 밀리초 단위 TTL\n  const acquired = await redis.set(\n    lockKey,\n    value,\n    'NX',\n    'PX',\n    timeout * 1000\n  );\n  \n  return acquired === 'OK';\n}\n\nasync function releaseLock(lockKey) {\n  await redis.del(lockKey);\n}\n\n// 사용 예\nconst locked = await acquireLock('order:123');\nif (locked) {\n  try {\n    // 임계 영역 작업\n    await processOrder(123);\n  } finally {\n    await releaseLock('order:123');\n  }\n}\n```\n\n### 5. Pub/Sub\n\n```javascript\n// Publisher\nawait redis.publish('notifications', JSON.stringify({\n  type: 'new_message',\n  userId: 123,\n  message: 'Hello!'\n}));\n\n// Subscriber\nconst subscriber = redis.duplicate();\nawait subscriber.subscribe('notifications');\n\nsubscriber.on('message', (channel, message) => {\n  const data = JSON.parse(message);\n  console.log('Received:', data);\n});\n```\n\n## 성능 최적화\n\n### 1. Pipeline\n\n```javascript\n// 여러 명령을 한번에 전송\nconst pipeline = redis.pipeline();\npipeline.set('key1', 'value1');\npipeline.set('key2', 'value2');\npipeline.get('key1');\nconst results = await pipeline.exec();\n```\n\n### 2. 적절한 자료구조 선택\n\n```javascript\n// ❌ 나쁜 예: String으로 객체 저장\nawait redis.set('user:1', JSON.stringify({ name: 'John', age: 30 }));\n\n// ✅ 좋은 예: Hash 사용\nawait redis.hset('user:1', 'name', 'John', 'age', 30);\n```\n\n### 3. 메모리 최적화\n\n```yaml\n# redis.conf\nmaxmemory 2gb\nmaxmemory-policy allkeys-lru  # LRU 정책으로 메모리 관리\n```\n\n## 결론\n\nRedis는 단순한 캐시를 넘어 세션, 큐, 실시간 분석 등 다양한 용도로 활용할 수 있는 강력한 도구입니다.\n적절한 캐싱 전략과 자료구조를 선택하면 애플리케이션 성능을 획기적으로 향상시킬 수 있습니다! 🚀\n\n"
  },
  {
    "id": "2025-10-08-mongodb-aggregation",
    "slug": "2025-10-08-mongodb-aggregation",
    "title": "MongoDB Aggregation Pipeline 마스터하기",
    "date": "2025-10-08",
    "category": "Database",
    "subcategory": "MongoDB",
    "tags": [
      "MongoDB",
      "Aggregation",
      "NoSQL",
      "Database"
    ],
    "excerpt": "MongoDB의 강력한 기능인 Aggregation Pipeline을 활용하여 복잡한 데이터 처리를 수행하는 방법을 배웁니다.",
    "author": "Geon Lee",
    "content": "<h1>MongoDB Aggregation Pipeline 마스터하기</h1>\n<p>MongoDB의 Aggregation Pipeline은 데이터를 단계별로 변환하고 분석할 수 있는 강력한 도구입니다.</p>\n<h2>Aggregation Pipeline이란?</h2>\n<p>여러 단계(stage)를 거쳐 데이터를 처리하는 파이프라인 방식의 프레임워크입니다.</p>\n<pre><code class=\"language-javascript\">db.collection.aggregate([\n  { $match: { ... } },\n  { $group: { ... } },\n  { $sort: { ... } }\n])\n</code></pre>\n<h2>주요 Stage 연산자</h2>\n<h3>$match - 필터링</h3>\n<pre><code class=\"language-javascript\">// 특정 조건에 맞는 문서만 선택\ndb.orders.aggregate([\n  {\n    $match: {\n      status: &quot;completed&quot;,\n      total: { $gte: 100 }\n    }\n  }\n])\n</code></pre>\n<h3>$project - 필드 선택/변환</h3>\n<pre><code class=\"language-javascript\">db.users.aggregate([\n  {\n    $project: {\n      _id: 0,\n      name: 1,\n      email: 1,\n      age: 1,\n      // 계산된 필드\n      isAdult: { $gte: [&quot;$age&quot;, 18] }\n    }\n  }\n])\n</code></pre>\n<h3>$group - 그룹화 및 집계</h3>\n<pre><code class=\"language-javascript\">// 도시별 사용자 수와 평균 나이\ndb.users.aggregate([\n  {\n    $group: {\n      _id: &quot;$city&quot;,\n      count: { $sum: 1 },\n      averageAge: { $avg: &quot;$age&quot; },\n      maxAge: { $max: &quot;$age&quot; },\n      minAge: { $min: &quot;$age&quot; }\n    }\n  }\n])\n</code></pre>\n<h3>$sort - 정렬</h3>\n<pre><code class=\"language-javascript\">db.orders.aggregate([\n  {\n    $sort: {\n      total: -1,  // 내림차순\n      date: 1     // 오름차순\n    }\n  }\n])\n</code></pre>\n<h3>$limit와 $skip - 페이징</h3>\n<pre><code class=\"language-javascript\">db.products.aggregate([\n  { $sort: { price: -1 } },\n  { $skip: 20 },   // 20개 건너뛰기\n  { $limit: 10 }   // 10개만 가져오기\n])\n</code></pre>\n<h3>$lookup - JOIN</h3>\n<pre><code class=\"language-javascript\">// SQL의 LEFT JOIN과 유사\ndb.orders.aggregate([\n  {\n    $lookup: {\n      from: &quot;users&quot;,           // 조인할 컬렉션\n      localField: &quot;userId&quot;,    // orders의 필드\n      foreignField: &quot;_id&quot;,     // users의 필드\n      as: &quot;userInfo&quot;          // 결과 필드명\n    }\n  }\n])\n</code></pre>\n<h3>$unwind - 배열 분해</h3>\n<pre><code class=\"language-javascript\">// 배열 요소를 개별 문서로 분해\ndb.products.aggregate([\n  {\n    $unwind: &quot;$tags&quot;\n  }\n])\n\n// 예시:\n// 입력: { name: &quot;Product&quot;, tags: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] }\n// 출력: \n// { name: &quot;Product&quot;, tags: &quot;a&quot; }\n// { name: &quot;Product&quot;, tags: &quot;b&quot; }\n// { name: &quot;Product&quot;, tags: &quot;c&quot; }\n</code></pre>\n<h2>실전 예제</h2>\n<h3>1. 월별 매출 통계</h3>\n<pre><code class=\"language-javascript\">db.orders.aggregate([\n  {\n    $match: {\n      status: &quot;completed&quot;,\n      orderDate: {\n        $gte: new Date(&quot;2024-01-01&quot;),\n        $lt: new Date(&quot;2025-01-01&quot;)\n      }\n    }\n  },\n  {\n    $group: {\n      _id: {\n        year: { $year: &quot;$orderDate&quot; },\n        month: { $month: &quot;$orderDate&quot; }\n      },\n      totalRevenue: { $sum: &quot;$total&quot; },\n      orderCount: { $sum: 1 },\n      averageOrderValue: { $avg: &quot;$total&quot; }\n    }\n  },\n  {\n    $sort: { &quot;_id.year&quot;: 1, &quot;_id.month&quot;: 1 }\n  },\n  {\n    $project: {\n      _id: 0,\n      year: &quot;$_id.year&quot;,\n      month: &quot;$_id.month&quot;,\n      totalRevenue: 1,\n      orderCount: 1,\n      averageOrderValue: { $round: [&quot;$averageOrderValue&quot;, 2] }\n    }\n  }\n])\n</code></pre>\n<h3>2. 상위 10개 제품 분석</h3>\n<pre><code class=\"language-javascript\">db.orderItems.aggregate([\n  {\n    $group: {\n      _id: &quot;$productId&quot;,\n      totalSold: { $sum: &quot;$quantity&quot; },\n      totalRevenue: { $sum: { $multiply: [&quot;$quantity&quot;, &quot;$price&quot;] } }\n    }\n  },\n  {\n    $lookup: {\n      from: &quot;products&quot;,\n      localField: &quot;_id&quot;,\n      foreignField: &quot;_id&quot;,\n      as: &quot;product&quot;\n    }\n  },\n  {\n    $unwind: &quot;$product&quot;\n  },\n  {\n    $project: {\n      productName: &quot;$product.name&quot;,\n      category: &quot;$product.category&quot;,\n      totalSold: 1,\n      totalRevenue: 1\n    }\n  },\n  {\n    $sort: { totalRevenue: -1 }\n  },\n  {\n    $limit: 10\n  }\n])\n</code></pre>\n<h3>3. 사용자 행동 분석</h3>\n<pre><code class=\"language-javascript\">db.events.aggregate([\n  {\n    $match: {\n      eventType: { $in: [&quot;click&quot;, &quot;purchase&quot;] }\n    }\n  },\n  {\n    $group: {\n      _id: &quot;$userId&quot;,\n      clicks: {\n        $sum: { $cond: [{ $eq: [&quot;$eventType&quot;, &quot;click&quot;] }, 1, 0] }\n      },\n      purchases: {\n        $sum: { $cond: [{ $eq: [&quot;$eventType&quot;, &quot;purchase&quot;] }, 1, 0] }\n      },\n      totalSpent: {\n        $sum: { $cond: [{ $eq: [&quot;$eventType&quot;, &quot;purchase&quot;] }, &quot;$amount&quot;, 0] }\n      }\n    }\n  },\n  {\n    $project: {\n      userId: &quot;$_id&quot;,\n      clicks: 1,\n      purchases: 1,\n      totalSpent: 1,\n      conversionRate: {\n        $cond: [\n          { $gt: [&quot;$clicks&quot;, 0] },\n          { $multiply: [{ $divide: [&quot;$purchases&quot;, &quot;$clicks&quot;] }, 100] },\n          0\n        ]\n      }\n    }\n  },\n  {\n    $sort: { totalSpent: -1 }\n  }\n])\n</code></pre>\n<h2>고급 연산자</h2>\n<h3>$facet - 다중 파이프라인</h3>\n<pre><code class=\"language-javascript\">db.products.aggregate([\n  {\n    $facet: {\n      // 카테고리별 통계\n      byCategory: [\n        { $group: { _id: &quot;$category&quot;, count: { $sum: 1 } } },\n        { $sort: { count: -1 } }\n      ],\n      // 가격대별 통계\n      byPriceRange: [\n        {\n          $bucket: {\n            groupBy: &quot;$price&quot;,\n            boundaries: [0, 50, 100, 200, 500],\n            default: &quot;500+&quot;,\n            output: { count: { $sum: 1 } }\n          }\n        }\n      ],\n      // 전체 통계\n      stats: [\n        {\n          $group: {\n            _id: null,\n            totalProducts: { $sum: 1 },\n            avgPrice: { $avg: &quot;$price&quot; },\n            maxPrice: { $max: &quot;$price&quot; }\n          }\n        }\n      ]\n    }\n  }\n])\n</code></pre>\n<h3>$bucket - 범위별 그룹화</h3>\n<pre><code class=\"language-javascript\">db.users.aggregate([\n  {\n    $bucket: {\n      groupBy: &quot;$age&quot;,\n      boundaries: [0, 20, 30, 40, 50, 60, 100],\n      default: &quot;Other&quot;,\n      output: {\n        count: { $sum: 1 },\n        users: { $push: &quot;$name&quot; }\n      }\n    }\n  }\n])\n</code></pre>\n<h3>$addFields - 필드 추가</h3>\n<pre><code class=\"language-javascript\">db.orders.aggregate([\n  {\n    $addFields: {\n      totalWithTax: {\n        $multiply: [&quot;$total&quot;, 1.1]\n      },\n      discountAmount: {\n        $multiply: [&quot;$total&quot;, { $divide: [&quot;$discountPercent&quot;, 100] }]\n      }\n    }\n  }\n])\n</code></pre>\n<h2>성능 최적화</h2>\n<h3>1. $match를 최대한 앞쪽에 배치</h3>\n<pre><code class=\"language-javascript\">// ✅ 좋은 예\ndb.orders.aggregate([\n  { $match: { status: &quot;completed&quot; } },  // 먼저 필터링\n  { $lookup: { ... } },\n  { $group: { ... } }\n])\n\n// ❌ 나쁜 예\ndb.orders.aggregate([\n  { $lookup: { ... } },  // 많은 데이터로 JOIN\n  { $match: { status: &quot;completed&quot; } }\n])\n</code></pre>\n<h3>2. 인덱스 활용</h3>\n<pre><code class=\"language-javascript\">// 인덱스 생성\ndb.orders.createIndex({ status: 1, orderDate: -1 })\n\n// $match에서 인덱스 활용\ndb.orders.aggregate([\n  {\n    $match: {\n      status: &quot;completed&quot;,\n      orderDate: { $gte: new Date(&quot;2024-01-01&quot;) }\n    }\n  }\n])\n</code></pre>\n<h3>3. $project로 필요한 필드만 선택</h3>\n<pre><code class=\"language-javascript\">db.users.aggregate([\n  { $match: { ... } },\n  {\n    $project: {  // 필요한 필드만 선택\n      name: 1,\n      email: 1,\n      age: 1\n    }\n  },\n  { $group: { ... } }\n])\n</code></pre>\n<h3>4. allowDiskUse 옵션</h3>\n<pre><code class=\"language-javascript\">// 메모리 제한(100MB) 초과 시 디스크 사용\ndb.collection.aggregate(\n  [ ... ],\n  { allowDiskUse: true }\n)\n</code></pre>\n<h2>실전 팁</h2>\n<h3>1. explain()으로 성능 분석</h3>\n<pre><code class=\"language-javascript\">db.orders.aggregate(\n  [ ... ],\n  { explain: true }\n)\n</code></pre>\n<h3>2. $out으로 결과 저장</h3>\n<pre><code class=\"language-javascript\">db.orders.aggregate([\n  { $group: { ... } },\n  {\n    $out: &quot;orderStatistics&quot;  // 새 컬렉션에 저장\n  }\n])\n</code></pre>\n<h3>3. $merge로 결과 병합</h3>\n<pre><code class=\"language-javascript\">db.events.aggregate([\n  { $group: { ... } },\n  {\n    $merge: {\n      into: &quot;eventSummary&quot;,\n      whenMatched: &quot;merge&quot;,\n      whenNotMatched: &quot;insert&quot;\n    }\n  }\n])\n</code></pre>\n<h2>결론</h2>\n<p>MongoDB Aggregation Pipeline은 복잡한 데이터 분석과 변환을 효율적으로 수행할 수 있는 강력한 도구입니다.<br>각 stage의 특성을 이해하고 적절히 조합하면, SQL 못지않게 강력한 쿼리를 작성할 수 있습니다! 🚀</p>\n",
    "rawContent": "\n# MongoDB Aggregation Pipeline 마스터하기\n\nMongoDB의 Aggregation Pipeline은 데이터를 단계별로 변환하고 분석할 수 있는 강력한 도구입니다.\n\n## Aggregation Pipeline이란?\n\n여러 단계(stage)를 거쳐 데이터를 처리하는 파이프라인 방식의 프레임워크입니다.\n\n```javascript\ndb.collection.aggregate([\n  { $match: { ... } },\n  { $group: { ... } },\n  { $sort: { ... } }\n])\n```\n\n## 주요 Stage 연산자\n\n### $match - 필터링\n\n```javascript\n// 특정 조건에 맞는 문서만 선택\ndb.orders.aggregate([\n  {\n    $match: {\n      status: \"completed\",\n      total: { $gte: 100 }\n    }\n  }\n])\n```\n\n### $project - 필드 선택/변환\n\n```javascript\ndb.users.aggregate([\n  {\n    $project: {\n      _id: 0,\n      name: 1,\n      email: 1,\n      age: 1,\n      // 계산된 필드\n      isAdult: { $gte: [\"$age\", 18] }\n    }\n  }\n])\n```\n\n### $group - 그룹화 및 집계\n\n```javascript\n// 도시별 사용자 수와 평균 나이\ndb.users.aggregate([\n  {\n    $group: {\n      _id: \"$city\",\n      count: { $sum: 1 },\n      averageAge: { $avg: \"$age\" },\n      maxAge: { $max: \"$age\" },\n      minAge: { $min: \"$age\" }\n    }\n  }\n])\n```\n\n### $sort - 정렬\n\n```javascript\ndb.orders.aggregate([\n  {\n    $sort: {\n      total: -1,  // 내림차순\n      date: 1     // 오름차순\n    }\n  }\n])\n```\n\n### $limit와 $skip - 페이징\n\n```javascript\ndb.products.aggregate([\n  { $sort: { price: -1 } },\n  { $skip: 20 },   // 20개 건너뛰기\n  { $limit: 10 }   // 10개만 가져오기\n])\n```\n\n### $lookup - JOIN\n\n```javascript\n// SQL의 LEFT JOIN과 유사\ndb.orders.aggregate([\n  {\n    $lookup: {\n      from: \"users\",           // 조인할 컬렉션\n      localField: \"userId\",    // orders의 필드\n      foreignField: \"_id\",     // users의 필드\n      as: \"userInfo\"          // 결과 필드명\n    }\n  }\n])\n```\n\n### $unwind - 배열 분해\n\n```javascript\n// 배열 요소를 개별 문서로 분해\ndb.products.aggregate([\n  {\n    $unwind: \"$tags\"\n  }\n])\n\n// 예시:\n// 입력: { name: \"Product\", tags: [\"a\", \"b\", \"c\"] }\n// 출력: \n// { name: \"Product\", tags: \"a\" }\n// { name: \"Product\", tags: \"b\" }\n// { name: \"Product\", tags: \"c\" }\n```\n\n## 실전 예제\n\n### 1. 월별 매출 통계\n\n```javascript\ndb.orders.aggregate([\n  {\n    $match: {\n      status: \"completed\",\n      orderDate: {\n        $gte: new Date(\"2024-01-01\"),\n        $lt: new Date(\"2025-01-01\")\n      }\n    }\n  },\n  {\n    $group: {\n      _id: {\n        year: { $year: \"$orderDate\" },\n        month: { $month: \"$orderDate\" }\n      },\n      totalRevenue: { $sum: \"$total\" },\n      orderCount: { $sum: 1 },\n      averageOrderValue: { $avg: \"$total\" }\n    }\n  },\n  {\n    $sort: { \"_id.year\": 1, \"_id.month\": 1 }\n  },\n  {\n    $project: {\n      _id: 0,\n      year: \"$_id.year\",\n      month: \"$_id.month\",\n      totalRevenue: 1,\n      orderCount: 1,\n      averageOrderValue: { $round: [\"$averageOrderValue\", 2] }\n    }\n  }\n])\n```\n\n### 2. 상위 10개 제품 분석\n\n```javascript\ndb.orderItems.aggregate([\n  {\n    $group: {\n      _id: \"$productId\",\n      totalSold: { $sum: \"$quantity\" },\n      totalRevenue: { $sum: { $multiply: [\"$quantity\", \"$price\"] } }\n    }\n  },\n  {\n    $lookup: {\n      from: \"products\",\n      localField: \"_id\",\n      foreignField: \"_id\",\n      as: \"product\"\n    }\n  },\n  {\n    $unwind: \"$product\"\n  },\n  {\n    $project: {\n      productName: \"$product.name\",\n      category: \"$product.category\",\n      totalSold: 1,\n      totalRevenue: 1\n    }\n  },\n  {\n    $sort: { totalRevenue: -1 }\n  },\n  {\n    $limit: 10\n  }\n])\n```\n\n### 3. 사용자 행동 분석\n\n```javascript\ndb.events.aggregate([\n  {\n    $match: {\n      eventType: { $in: [\"click\", \"purchase\"] }\n    }\n  },\n  {\n    $group: {\n      _id: \"$userId\",\n      clicks: {\n        $sum: { $cond: [{ $eq: [\"$eventType\", \"click\"] }, 1, 0] }\n      },\n      purchases: {\n        $sum: { $cond: [{ $eq: [\"$eventType\", \"purchase\"] }, 1, 0] }\n      },\n      totalSpent: {\n        $sum: { $cond: [{ $eq: [\"$eventType\", \"purchase\"] }, \"$amount\", 0] }\n      }\n    }\n  },\n  {\n    $project: {\n      userId: \"$_id\",\n      clicks: 1,\n      purchases: 1,\n      totalSpent: 1,\n      conversionRate: {\n        $cond: [\n          { $gt: [\"$clicks\", 0] },\n          { $multiply: [{ $divide: [\"$purchases\", \"$clicks\"] }, 100] },\n          0\n        ]\n      }\n    }\n  },\n  {\n    $sort: { totalSpent: -1 }\n  }\n])\n```\n\n## 고급 연산자\n\n### $facet - 다중 파이프라인\n\n```javascript\ndb.products.aggregate([\n  {\n    $facet: {\n      // 카테고리별 통계\n      byCategory: [\n        { $group: { _id: \"$category\", count: { $sum: 1 } } },\n        { $sort: { count: -1 } }\n      ],\n      // 가격대별 통계\n      byPriceRange: [\n        {\n          $bucket: {\n            groupBy: \"$price\",\n            boundaries: [0, 50, 100, 200, 500],\n            default: \"500+\",\n            output: { count: { $sum: 1 } }\n          }\n        }\n      ],\n      // 전체 통계\n      stats: [\n        {\n          $group: {\n            _id: null,\n            totalProducts: { $sum: 1 },\n            avgPrice: { $avg: \"$price\" },\n            maxPrice: { $max: \"$price\" }\n          }\n        }\n      ]\n    }\n  }\n])\n```\n\n### $bucket - 범위별 그룹화\n\n```javascript\ndb.users.aggregate([\n  {\n    $bucket: {\n      groupBy: \"$age\",\n      boundaries: [0, 20, 30, 40, 50, 60, 100],\n      default: \"Other\",\n      output: {\n        count: { $sum: 1 },\n        users: { $push: \"$name\" }\n      }\n    }\n  }\n])\n```\n\n### $addFields - 필드 추가\n\n```javascript\ndb.orders.aggregate([\n  {\n    $addFields: {\n      totalWithTax: {\n        $multiply: [\"$total\", 1.1]\n      },\n      discountAmount: {\n        $multiply: [\"$total\", { $divide: [\"$discountPercent\", 100] }]\n      }\n    }\n  }\n])\n```\n\n## 성능 최적화\n\n### 1. $match를 최대한 앞쪽에 배치\n\n```javascript\n// ✅ 좋은 예\ndb.orders.aggregate([\n  { $match: { status: \"completed\" } },  // 먼저 필터링\n  { $lookup: { ... } },\n  { $group: { ... } }\n])\n\n// ❌ 나쁜 예\ndb.orders.aggregate([\n  { $lookup: { ... } },  // 많은 데이터로 JOIN\n  { $match: { status: \"completed\" } }\n])\n```\n\n### 2. 인덱스 활용\n\n```javascript\n// 인덱스 생성\ndb.orders.createIndex({ status: 1, orderDate: -1 })\n\n// $match에서 인덱스 활용\ndb.orders.aggregate([\n  {\n    $match: {\n      status: \"completed\",\n      orderDate: { $gte: new Date(\"2024-01-01\") }\n    }\n  }\n])\n```\n\n### 3. $project로 필요한 필드만 선택\n\n```javascript\ndb.users.aggregate([\n  { $match: { ... } },\n  {\n    $project: {  // 필요한 필드만 선택\n      name: 1,\n      email: 1,\n      age: 1\n    }\n  },\n  { $group: { ... } }\n])\n```\n\n### 4. allowDiskUse 옵션\n\n```javascript\n// 메모리 제한(100MB) 초과 시 디스크 사용\ndb.collection.aggregate(\n  [ ... ],\n  { allowDiskUse: true }\n)\n```\n\n## 실전 팁\n\n### 1. explain()으로 성능 분석\n\n```javascript\ndb.orders.aggregate(\n  [ ... ],\n  { explain: true }\n)\n```\n\n### 2. $out으로 결과 저장\n\n```javascript\ndb.orders.aggregate([\n  { $group: { ... } },\n  {\n    $out: \"orderStatistics\"  // 새 컬렉션에 저장\n  }\n])\n```\n\n### 3. $merge로 결과 병합\n\n```javascript\ndb.events.aggregate([\n  { $group: { ... } },\n  {\n    $merge: {\n      into: \"eventSummary\",\n      whenMatched: \"merge\",\n      whenNotMatched: \"insert\"\n    }\n  }\n])\n```\n\n## 결론\n\nMongoDB Aggregation Pipeline은 복잡한 데이터 분석과 변환을 효율적으로 수행할 수 있는 강력한 도구입니다.\n각 stage의 특성을 이해하고 적절히 조합하면, SQL 못지않게 강력한 쿼리를 작성할 수 있습니다! 🚀\n\n"
  },
  {
    "id": "2025-10-07-mysql-optimization",
    "slug": "2025-10-07-mysql-optimization",
    "title": "MySQL 쿼리 성능 최적화 가이드",
    "date": "2025-10-07",
    "category": "Database",
    "subcategory": "MySQL",
    "tags": [
      "MySQL",
      "Database",
      "Performance",
      "Optimization"
    ],
    "excerpt": "MySQL 쿼리 성능을 향상시키는 다양한 최적화 기법과 인덱스 전략을 알아봅니다.",
    "author": "Geon Lee",
    "content": "<h1>MySQL 쿼리 성능 최적화 가이드</h1>\n<p>MySQL 데이터베이스의 성능을 최적화하는 것은 애플리케이션 전체 성능에 큰 영향을 미칩니다.</p>\n<h2>인덱스 (Index)</h2>\n<h3>인덱스 생성</h3>\n<pre><code class=\"language-sql\">-- 단일 컬럼 인덱스\nCREATE INDEX idx_email ON users(email);\n\n-- 복합 인덱스\nCREATE INDEX idx_name_age ON users(name, age);\n\n-- 유니크 인덱스\nCREATE UNIQUE INDEX idx_username ON users(username);\n\n-- 전문 검색 인덱스\nCREATE FULLTEXT INDEX idx_content ON posts(content);\n</code></pre>\n<h3>인덱스 사용 원칙</h3>\n<pre><code class=\"language-sql\">-- ✅ 좋은 예: 인덱스 활용\nSELECT * FROM users WHERE email = &#39;john@example.com&#39;;\n\n-- ❌ 나쁜 예: 인덱스 사용 불가 (함수 사용)\nSELECT * FROM users WHERE UPPER(email) = &#39;JOHN@EXAMPLE.COM&#39;;\n\n-- ✅ 개선: 인덱스 활용 가능\nSELECT * FROM users WHERE email = LOWER(&#39;JOHN@EXAMPLE.COM&#39;);\n</code></pre>\n<h2>EXPLAIN을 활용한 쿼리 분석</h2>\n<pre><code class=\"language-sql\">EXPLAIN SELECT * FROM users WHERE age &gt; 20;\n</code></pre>\n<h3>주요 컬럼 해석</h3>\n<ul>\n<li><p><strong>type</strong>: 조인 타입 (ALL, index, range, ref, eq_ref, const)</p>\n<ul>\n<li>ALL: 전체 테이블 스캔 (피해야 함)</li>\n<li>index: 인덱스 전체 스캔</li>\n<li>range: 인덱스 범위 스캔</li>\n<li>ref: 인덱스를 사용한 동등 비교</li>\n<li>const: 기본 키나 유니크 키로 단일 행 접근</li>\n</ul>\n</li>\n<li><p><strong>key</strong>: 실제 사용된 인덱스</p>\n</li>\n<li><p><strong>rows</strong>: 검사할 예상 행 수 (적을수록 좋음)</p>\n</li>\n<li><p><strong>Extra</strong>: 추가 정보</p>\n<ul>\n<li>Using filesort: 정렬 필요 (인덱스로 개선 가능)</li>\n<li>Using temporary: 임시 테이블 사용 (피해야 함)</li>\n<li>Using index: 커버링 인덱스 사용 (좋음)</li>\n</ul>\n</li>\n</ul>\n<h2>쿼리 최적화 기법</h2>\n<h3>1. SELECT * 피하기</h3>\n<pre><code class=\"language-sql\">-- ❌ 나쁜 예\nSELECT * FROM users WHERE id = 1;\n\n-- ✅ 좋은 예\nSELECT id, name, email FROM users WHERE id = 1;\n</code></pre>\n<h3>2. WHERE 조건 최적화</h3>\n<pre><code class=\"language-sql\">-- ❌ 나쁜 예: 인덱스 사용 불가\nSELECT * FROM users WHERE age + 10 &gt; 30;\n\n-- ✅ 좋은 예: 인덱스 사용 가능\nSELECT * FROM users WHERE age &gt; 20;\n\n-- ❌ 나쁜 예: LIKE 앞에 %\nSELECT * FROM users WHERE name LIKE &#39;%john%&#39;;\n\n-- ✅ 좋은 예: LIKE 뒤에만 %\nSELECT * FROM users WHERE name LIKE &#39;john%&#39;;\n</code></pre>\n<h3>3. JOIN 최적화</h3>\n<pre><code class=\"language-sql\">-- ❌ 나쁜 예: 서브쿼리\nSELECT * FROM users \nWHERE id IN (SELECT user_id FROM orders WHERE total &gt; 100);\n\n-- ✅ 좋은 예: JOIN 사용\nSELECT DISTINCT u.* \nFROM users u\nINNER JOIN orders o ON u.id = o.user_id\nWHERE o.total &gt; 100;\n</code></pre>\n<h3>4. 페이징 최적화</h3>\n<pre><code class=\"language-sql\">-- ❌ 나쁜 예: OFFSET이 클 때 느림\nSELECT * FROM posts \nORDER BY created_at DESC\nLIMIT 100 OFFSET 100000;\n\n-- ✅ 좋은 예: 키 기반 페이징\nSELECT * FROM posts \nWHERE id &lt; :last_id\nORDER BY id DESC\nLIMIT 100;\n</code></pre>\n<h3>5. COUNT 최적화</h3>\n<pre><code class=\"language-sql\">-- ❌ 나쁜 예: 전체 행 카운트\nSELECT COUNT(*) FROM users;\n\n-- ✅ 좋은 예: 조건이 있는 경우 인덱스 활용\nSELECT COUNT(*) FROM users WHERE status = &#39;active&#39;;\n\n-- 더 좋은 방법: 근사치 사용\nSELECT TABLE_ROWS \nFROM information_schema.TABLES \nWHERE TABLE_NAME = &#39;users&#39;;\n</code></pre>\n<h2>복합 인덱스 최적화</h2>\n<h3>인덱스 컬럼 순서</h3>\n<pre><code class=\"language-sql\">-- 인덱스: (city, age, name)\n-- ✅ 인덱스 사용: city 사용\nSELECT * FROM users WHERE city = &#39;Seoul&#39;;\n\n-- ✅ 인덱스 사용: city, age 사용\nSELECT * FROM users WHERE city = &#39;Seoul&#39; AND age &gt; 20;\n\n-- ✅ 인덱스 완전 사용\nSELECT * FROM users WHERE city = &#39;Seoul&#39; AND age &gt; 20 AND name = &#39;John&#39;;\n\n-- ❌ 인덱스 사용 불가: city 없음\nSELECT * FROM users WHERE age &gt; 20 AND name = &#39;John&#39;;\n</code></pre>\n<h3>커버링 인덱스</h3>\n<pre><code class=\"language-sql\">-- 인덱스: (email, name, age)\n-- 커버링 인덱스: 테이블 접근 없이 인덱스만으로 결과 반환\nSELECT name, age FROM users WHERE email = &#39;john@example.com&#39;;\n</code></pre>\n<h2>파티셔닝</h2>\n<h3>Range 파티셔닝</h3>\n<pre><code class=\"language-sql\">CREATE TABLE orders (\n    id INT,\n    order_date DATE,\n    amount DECIMAL(10, 2)\n)\nPARTITION BY RANGE (YEAR(order_date)) (\n    PARTITION p2022 VALUES LESS THAN (2023),\n    PARTITION p2023 VALUES LESS THAN (2024),\n    PARTITION p2024 VALUES LESS THAN (2025),\n    PARTITION p_future VALUES LESS THAN MAXVALUE\n);\n</code></pre>\n<h3>List 파티셔닝</h3>\n<pre><code class=\"language-sql\">CREATE TABLE users (\n    id INT,\n    name VARCHAR(100),\n    country VARCHAR(50)\n)\nPARTITION BY LIST COLUMNS(country) (\n    PARTITION p_asia VALUES IN (&#39;Korea&#39;, &#39;Japan&#39;, &#39;China&#39;),\n    PARTITION p_america VALUES IN (&#39;USA&#39;, &#39;Canada&#39;),\n    PARTITION p_europe VALUES IN (&#39;UK&#39;, &#39;Germany&#39;, &#39;France&#39;)\n);\n</code></pre>\n<h2>트랜잭션 최적화</h2>\n<h3>1. 트랜잭션 범위 최소화</h3>\n<pre><code class=\"language-sql\">-- ❌ 나쁜 예: 긴 트랜잭션\nSTART TRANSACTION;\nSELECT * FROM users WHERE id = 1 FOR UPDATE;\n-- 복잡한 비즈니스 로직 처리...\nUPDATE users SET balance = balance - 100 WHERE id = 1;\nCOMMIT;\n\n-- ✅ 좋은 예: 짧은 트랜잭션\n-- 비즈니스 로직 먼저 처리\nSTART TRANSACTION;\nUPDATE users SET balance = balance - 100 WHERE id = 1;\nCOMMIT;\n</code></pre>\n<h3>2. 적절한 격리 수준</h3>\n<pre><code class=\"language-sql\">-- READ COMMITTED (기본값 대체)\nSET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;\n\n-- REPEATABLE READ (MySQL 기본값)\nSET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;\n</code></pre>\n<h2>캐싱 전략</h2>\n<h3>쿼리 캐시 (MySQL 5.7 이하)</h3>\n<pre><code class=\"language-sql\">-- 쿼리 캐시 사용\nSELECT SQL_CACHE * FROM users WHERE id = 1;\n\n-- 쿼리 캐시 미사용\nSELECT SQL_NO_CACHE * FROM users WHERE id = 1;\n</code></pre>\n<h3>애플리케이션 레벨 캐싱</h3>\n<pre><code class=\"language-javascript\">// Redis 캐싱 예제\nasync function getUser(id) {\n  const cacheKey = `user:${id}`;\n  \n  // 캐시 확인\n  let user = await redis.get(cacheKey);\n  \n  if (!user) {\n    // DB 조회\n    user = await db.query(&#39;SELECT * FROM users WHERE id = ?&#39;, [id]);\n    // 캐시 저장 (10분)\n    await redis.setex(cacheKey, 600, JSON.stringify(user));\n  }\n  \n  return JSON.parse(user);\n}\n</code></pre>\n<h2>벌크 작업 최적화</h2>\n<h3>INSERT 최적화</h3>\n<pre><code class=\"language-sql\">-- ❌ 나쁜 예: 개별 INSERT\nINSERT INTO users (name, email) VALUES (&#39;John&#39;, &#39;john@example.com&#39;);\nINSERT INTO users (name, email) VALUES (&#39;Jane&#39;, &#39;jane@example.com&#39;);\n\n-- ✅ 좋은 예: 벌크 INSERT\nINSERT INTO users (name, email) VALUES \n(&#39;John&#39;, &#39;john@example.com&#39;),\n(&#39;Jane&#39;, &#39;jane@example.com&#39;),\n(&#39;Bob&#39;, &#39;bob@example.com&#39;);\n</code></pre>\n<h3>UPDATE 최적화</h3>\n<pre><code class=\"language-sql\">-- ❌ 나쁜 예: 불필요한 UPDATE\nUPDATE users SET updated_at = NOW();\n\n-- ✅ 좋은 예: 조건을 통한 최소화\nUPDATE users SET updated_at = NOW() WHERE status = &#39;active&#39;;\n</code></pre>\n<h2>데이터베이스 설정 최적화</h2>\n<h3>my.cnf 주요 설정</h3>\n<pre><code class=\"language-ini\">[mysqld]\n# InnoDB 버퍼 풀 (물리 메모리의 70-80%)\ninnodb_buffer_pool_size = 4G\n\n# 로그 파일 크기\ninnodb_log_file_size = 256M\n\n# 최대 연결 수\nmax_connections = 200\n\n# 쿼리 캐시 (MySQL 8.0 제거됨)\nquery_cache_size = 0\nquery_cache_type = 0\n\n# 정렬 버퍼\nsort_buffer_size = 2M\n\n# 조인 버퍼\njoin_buffer_size = 2M\n</code></pre>\n<h2>모니터링</h2>\n<h3>느린 쿼리 로그</h3>\n<pre><code class=\"language-sql\">-- 활성화\nSET GLOBAL slow_query_log = &#39;ON&#39;;\nSET GLOBAL long_query_time = 2;\n\n-- 로그 확인\nSELECT * FROM mysql.slow_log \nORDER BY start_time DESC \nLIMIT 10;\n</code></pre>\n<h3>실시간 쿼리 확인</h3>\n<pre><code class=\"language-sql\">SHOW PROCESSLIST;\n\n-- 또는\nSELECT * FROM information_schema.PROCESSLIST \nWHERE COMMAND != &#39;Sleep&#39;;\n</code></pre>\n<h2>결론</h2>\n<p>MySQL 성능 최적화는 지속적인 모니터링과 개선이 필요합니다.<br>인덱스를 적절히 설계하고, 쿼리를 최적화하며, 시스템 설정을 조정하면 극적인 성능 향상을 얻을 수 있습니다! 🚀</p>\n",
    "rawContent": "\n# MySQL 쿼리 성능 최적화 가이드\n\nMySQL 데이터베이스의 성능을 최적화하는 것은 애플리케이션 전체 성능에 큰 영향을 미칩니다.\n\n## 인덱스 (Index)\n\n### 인덱스 생성\n\n```sql\n-- 단일 컬럼 인덱스\nCREATE INDEX idx_email ON users(email);\n\n-- 복합 인덱스\nCREATE INDEX idx_name_age ON users(name, age);\n\n-- 유니크 인덱스\nCREATE UNIQUE INDEX idx_username ON users(username);\n\n-- 전문 검색 인덱스\nCREATE FULLTEXT INDEX idx_content ON posts(content);\n```\n\n### 인덱스 사용 원칙\n\n```sql\n-- ✅ 좋은 예: 인덱스 활용\nSELECT * FROM users WHERE email = 'john@example.com';\n\n-- ❌ 나쁜 예: 인덱스 사용 불가 (함수 사용)\nSELECT * FROM users WHERE UPPER(email) = 'JOHN@EXAMPLE.COM';\n\n-- ✅ 개선: 인덱스 활용 가능\nSELECT * FROM users WHERE email = LOWER('JOHN@EXAMPLE.COM');\n```\n\n## EXPLAIN을 활용한 쿼리 분석\n\n```sql\nEXPLAIN SELECT * FROM users WHERE age > 20;\n```\n\n### 주요 컬럼 해석\n\n- **type**: 조인 타입 (ALL, index, range, ref, eq_ref, const)\n  - ALL: 전체 테이블 스캔 (피해야 함)\n  - index: 인덱스 전체 스캔\n  - range: 인덱스 범위 스캔\n  - ref: 인덱스를 사용한 동등 비교\n  - const: 기본 키나 유니크 키로 단일 행 접근\n\n- **key**: 실제 사용된 인덱스\n- **rows**: 검사할 예상 행 수 (적을수록 좋음)\n- **Extra**: 추가 정보\n  - Using filesort: 정렬 필요 (인덱스로 개선 가능)\n  - Using temporary: 임시 테이블 사용 (피해야 함)\n  - Using index: 커버링 인덱스 사용 (좋음)\n\n## 쿼리 최적화 기법\n\n### 1. SELECT * 피하기\n\n```sql\n-- ❌ 나쁜 예\nSELECT * FROM users WHERE id = 1;\n\n-- ✅ 좋은 예\nSELECT id, name, email FROM users WHERE id = 1;\n```\n\n### 2. WHERE 조건 최적화\n\n```sql\n-- ❌ 나쁜 예: 인덱스 사용 불가\nSELECT * FROM users WHERE age + 10 > 30;\n\n-- ✅ 좋은 예: 인덱스 사용 가능\nSELECT * FROM users WHERE age > 20;\n\n-- ❌ 나쁜 예: LIKE 앞에 %\nSELECT * FROM users WHERE name LIKE '%john%';\n\n-- ✅ 좋은 예: LIKE 뒤에만 %\nSELECT * FROM users WHERE name LIKE 'john%';\n```\n\n### 3. JOIN 최적화\n\n```sql\n-- ❌ 나쁜 예: 서브쿼리\nSELECT * FROM users \nWHERE id IN (SELECT user_id FROM orders WHERE total > 100);\n\n-- ✅ 좋은 예: JOIN 사용\nSELECT DISTINCT u.* \nFROM users u\nINNER JOIN orders o ON u.id = o.user_id\nWHERE o.total > 100;\n```\n\n### 4. 페이징 최적화\n\n```sql\n-- ❌ 나쁜 예: OFFSET이 클 때 느림\nSELECT * FROM posts \nORDER BY created_at DESC\nLIMIT 100 OFFSET 100000;\n\n-- ✅ 좋은 예: 키 기반 페이징\nSELECT * FROM posts \nWHERE id < :last_id\nORDER BY id DESC\nLIMIT 100;\n```\n\n### 5. COUNT 최적화\n\n```sql\n-- ❌ 나쁜 예: 전체 행 카운트\nSELECT COUNT(*) FROM users;\n\n-- ✅ 좋은 예: 조건이 있는 경우 인덱스 활용\nSELECT COUNT(*) FROM users WHERE status = 'active';\n\n-- 더 좋은 방법: 근사치 사용\nSELECT TABLE_ROWS \nFROM information_schema.TABLES \nWHERE TABLE_NAME = 'users';\n```\n\n## 복합 인덱스 최적화\n\n### 인덱스 컬럼 순서\n\n```sql\n-- 인덱스: (city, age, name)\n-- ✅ 인덱스 사용: city 사용\nSELECT * FROM users WHERE city = 'Seoul';\n\n-- ✅ 인덱스 사용: city, age 사용\nSELECT * FROM users WHERE city = 'Seoul' AND age > 20;\n\n-- ✅ 인덱스 완전 사용\nSELECT * FROM users WHERE city = 'Seoul' AND age > 20 AND name = 'John';\n\n-- ❌ 인덱스 사용 불가: city 없음\nSELECT * FROM users WHERE age > 20 AND name = 'John';\n```\n\n### 커버링 인덱스\n\n```sql\n-- 인덱스: (email, name, age)\n-- 커버링 인덱스: 테이블 접근 없이 인덱스만으로 결과 반환\nSELECT name, age FROM users WHERE email = 'john@example.com';\n```\n\n## 파티셔닝\n\n### Range 파티셔닝\n\n```sql\nCREATE TABLE orders (\n    id INT,\n    order_date DATE,\n    amount DECIMAL(10, 2)\n)\nPARTITION BY RANGE (YEAR(order_date)) (\n    PARTITION p2022 VALUES LESS THAN (2023),\n    PARTITION p2023 VALUES LESS THAN (2024),\n    PARTITION p2024 VALUES LESS THAN (2025),\n    PARTITION p_future VALUES LESS THAN MAXVALUE\n);\n```\n\n### List 파티셔닝\n\n```sql\nCREATE TABLE users (\n    id INT,\n    name VARCHAR(100),\n    country VARCHAR(50)\n)\nPARTITION BY LIST COLUMNS(country) (\n    PARTITION p_asia VALUES IN ('Korea', 'Japan', 'China'),\n    PARTITION p_america VALUES IN ('USA', 'Canada'),\n    PARTITION p_europe VALUES IN ('UK', 'Germany', 'France')\n);\n```\n\n## 트랜잭션 최적화\n\n### 1. 트랜잭션 범위 최소화\n\n```sql\n-- ❌ 나쁜 예: 긴 트랜잭션\nSTART TRANSACTION;\nSELECT * FROM users WHERE id = 1 FOR UPDATE;\n-- 복잡한 비즈니스 로직 처리...\nUPDATE users SET balance = balance - 100 WHERE id = 1;\nCOMMIT;\n\n-- ✅ 좋은 예: 짧은 트랜잭션\n-- 비즈니스 로직 먼저 처리\nSTART TRANSACTION;\nUPDATE users SET balance = balance - 100 WHERE id = 1;\nCOMMIT;\n```\n\n### 2. 적절한 격리 수준\n\n```sql\n-- READ COMMITTED (기본값 대체)\nSET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;\n\n-- REPEATABLE READ (MySQL 기본값)\nSET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;\n```\n\n## 캐싱 전략\n\n### 쿼리 캐시 (MySQL 5.7 이하)\n\n```sql\n-- 쿼리 캐시 사용\nSELECT SQL_CACHE * FROM users WHERE id = 1;\n\n-- 쿼리 캐시 미사용\nSELECT SQL_NO_CACHE * FROM users WHERE id = 1;\n```\n\n### 애플리케이션 레벨 캐싱\n\n```javascript\n// Redis 캐싱 예제\nasync function getUser(id) {\n  const cacheKey = `user:${id}`;\n  \n  // 캐시 확인\n  let user = await redis.get(cacheKey);\n  \n  if (!user) {\n    // DB 조회\n    user = await db.query('SELECT * FROM users WHERE id = ?', [id]);\n    // 캐시 저장 (10분)\n    await redis.setex(cacheKey, 600, JSON.stringify(user));\n  }\n  \n  return JSON.parse(user);\n}\n```\n\n## 벌크 작업 최적화\n\n### INSERT 최적화\n\n```sql\n-- ❌ 나쁜 예: 개별 INSERT\nINSERT INTO users (name, email) VALUES ('John', 'john@example.com');\nINSERT INTO users (name, email) VALUES ('Jane', 'jane@example.com');\n\n-- ✅ 좋은 예: 벌크 INSERT\nINSERT INTO users (name, email) VALUES \n('John', 'john@example.com'),\n('Jane', 'jane@example.com'),\n('Bob', 'bob@example.com');\n```\n\n### UPDATE 최적화\n\n```sql\n-- ❌ 나쁜 예: 불필요한 UPDATE\nUPDATE users SET updated_at = NOW();\n\n-- ✅ 좋은 예: 조건을 통한 최소화\nUPDATE users SET updated_at = NOW() WHERE status = 'active';\n```\n\n## 데이터베이스 설정 최적화\n\n### my.cnf 주요 설정\n\n```ini\n[mysqld]\n# InnoDB 버퍼 풀 (물리 메모리의 70-80%)\ninnodb_buffer_pool_size = 4G\n\n# 로그 파일 크기\ninnodb_log_file_size = 256M\n\n# 최대 연결 수\nmax_connections = 200\n\n# 쿼리 캐시 (MySQL 8.0 제거됨)\nquery_cache_size = 0\nquery_cache_type = 0\n\n# 정렬 버퍼\nsort_buffer_size = 2M\n\n# 조인 버퍼\njoin_buffer_size = 2M\n```\n\n## 모니터링\n\n### 느린 쿼리 로그\n\n```sql\n-- 활성화\nSET GLOBAL slow_query_log = 'ON';\nSET GLOBAL long_query_time = 2;\n\n-- 로그 확인\nSELECT * FROM mysql.slow_log \nORDER BY start_time DESC \nLIMIT 10;\n```\n\n### 실시간 쿼리 확인\n\n```sql\nSHOW PROCESSLIST;\n\n-- 또는\nSELECT * FROM information_schema.PROCESSLIST \nWHERE COMMAND != 'Sleep';\n```\n\n## 결론\n\nMySQL 성능 최적화는 지속적인 모니터링과 개선이 필요합니다.\n인덱스를 적절히 설계하고, 쿼리를 최적화하며, 시스템 설정을 조정하면 극적인 성능 향상을 얻을 수 있습니다! 🚀\n\n"
  },
  {
    "id": "2025-10-06-typescript-tips",
    "slug": "2025-10-06-typescript-tips",
    "title": "TypeScript 실전 팁 모음",
    "date": "2025-10-06",
    "category": "Language",
    "subcategory": "TypeScript",
    "tags": [
      "TypeScript",
      "JavaScript",
      "개발팁"
    ],
    "excerpt": "실무에서 바로 사용할 수 있는 TypeScript 팁들을 모았습니다. 타입 가드, 유틸리티 타입, 제네릭 활용법 등을 다룹니다.",
    "author": "Geon Lee",
    "content": "<h1>TypeScript 실전 팁 모음 💎</h1>\n<p>실무에서 자주 사용하는 TypeScript 패턴과 팁들을 정리했습니다.</p>\n<h2>1. 타입 가드 (Type Guards)</h2>\n<p>런타임에서 타입을 좁혀나가는 방법입니다.</p>\n<pre><code class=\"language-typescript\">// typeof 사용\nfunction padLeft(value: string, padding: string | number) {\n  if (typeof padding === &quot;number&quot;) {\n    return Array(padding + 1).join(&quot; &quot;) + value;\n  }\n  return padding + value;\n}\n\n// instanceof 사용\nclass Dog {\n  bark() { console.log(&quot;멍멍!&quot;); }\n}\n\nclass Cat {\n  meow() { console.log(&quot;야옹~&quot;); }\n}\n\nfunction makeSound(animal: Dog | Cat) {\n  if (animal instanceof Dog) {\n    animal.bark();\n  } else {\n    animal.meow();\n  }\n}\n\n// 사용자 정의 타입 가드\ninterface Fish {\n  swim: () =&gt; void;\n}\n\ninterface Bird {\n  fly: () =&gt; void;\n}\n\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined;\n}\n</code></pre>\n<h2>2. 유틸리티 타입 활용</h2>\n<p>TypeScript에서 제공하는 내장 유틸리티 타입들입니다.</p>\n<pre><code class=\"language-typescript\">interface User {\n  id: number;\n  name: string;\n  email: string;\n  age?: number;\n}\n\n// Partial - 모든 속성을 선택적으로\ntype PartialUser = Partial&lt;User&gt;;\n// { id?: number; name?: string; email?: string; age?: number }\n\n// Required - 모든 속성을 필수로\ntype RequiredUser = Required&lt;User&gt;;\n// { id: number; name: string; email: string; age: number }\n\n// Pick - 특정 속성만 선택\ntype UserBasic = Pick&lt;User, &#39;id&#39; | &#39;name&#39;&gt;;\n// { id: number; name: string }\n\n// Omit - 특정 속성 제외\ntype UserWithoutEmail = Omit&lt;User, &#39;email&#39;&gt;;\n// { id: number; name: string; age?: number }\n\n// Record - 키-값 쌍 타입 생성\ntype PageInfo = Record&lt;&#39;home&#39; | &#39;about&#39; | &#39;contact&#39;, { title: string }&gt;;\n// { home: { title: string }, about: { title: string }, contact: { title: string } }\n</code></pre>\n<h2>3. 제네릭 활용</h2>\n<p>재사용 가능한 컴포넌트를 만들 때 필수입니다.</p>\n<pre><code class=\"language-typescript\">// 기본 제네릭 함수\nfunction identity&lt;T&gt;(arg: T): T {\n  return arg;\n}\n\n// 배열 제네릭\nfunction getFirstElement&lt;T&gt;(arr: T[]): T | undefined {\n  return arr[0];\n}\n\n// 제약 조건이 있는 제네릭\ninterface Lengthwise {\n  length: number;\n}\n\nfunction logLength&lt;T extends Lengthwise&gt;(arg: T): void {\n  console.log(arg.length);\n}\n\n// 클래스에서 제네릭 사용\nclass DataStore&lt;T&gt; {\n  private data: T[] = [];\n\n  add(item: T): void {\n    this.data.push(item);\n  }\n\n  get(index: number): T | undefined {\n    return this.data[index];\n  }\n\n  getAll(): T[] {\n    return [...this.data];\n  }\n}\n\nconst numberStore = new DataStore&lt;number&gt;();\nnumberStore.add(1);\nnumberStore.add(2);\n</code></pre>\n<h2>4. 고급 타입 패턴</h2>\n<h3>Union vs Intersection</h3>\n<pre><code class=\"language-typescript\">// Union (|) - 둘 중 하나\ntype Status = &#39;idle&#39; | &#39;loading&#39; | &#39;success&#39; | &#39;error&#39;;\n\n// Intersection (&amp;) - 모두 포함\ntype Admin = User &amp; {\n  permissions: string[];\n};\n</code></pre>\n<h3>Discriminated Union</h3>\n<pre><code class=\"language-typescript\">type Shape = \n  | { kind: &#39;circle&#39;; radius: number }\n  | { kind: &#39;square&#39;; size: number }\n  | { kind: &#39;rectangle&#39;; width: number; height: number };\n\nfunction area(shape: Shape): number {\n  switch (shape.kind) {\n    case &#39;circle&#39;:\n      return Math.PI * shape.radius ** 2;\n    case &#39;square&#39;:\n      return shape.size ** 2;\n    case &#39;rectangle&#39;:\n      return shape.width * shape.height;\n  }\n}\n</code></pre>\n<h3>Mapped Types</h3>\n<pre><code class=\"language-typescript\">type ReadOnly&lt;T&gt; = {\n  readonly [P in keyof T]: T[P];\n};\n\ntype Nullable&lt;T&gt; = {\n  [P in keyof T]: T[P] | null;\n};\n\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n}\n\ntype ReadonlyProduct = ReadOnly&lt;Product&gt;;\ntype NullableProduct = Nullable&lt;Product&gt;;\n</code></pre>\n<h2>5. 타입 추론 활용</h2>\n<pre><code class=\"language-typescript\">// 함수 반환 타입 추론\nconst createUser = () =&gt; ({\n  id: 1,\n  name: &#39;John&#39;,\n  email: &#39;john@example.com&#39;\n});\n\ntype User = ReturnType&lt;typeof createUser&gt;;\n// { id: number; name: string; email: string }\n\n// 매개변수 타입 추론\nfunction greet(name: string) {\n  return `Hello, ${name}`;\n}\n\ntype GreetParams = Parameters&lt;typeof greet&gt;;\n// [name: string]\n</code></pre>\n<h2>6. 실전 예제: API 응답 타입</h2>\n<pre><code class=\"language-typescript\">interface ApiResponse&lt;T&gt; {\n  data: T;\n  status: number;\n  message: string;\n}\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nasync function fetchUser(id: number): Promise&lt;ApiResponse&lt;User&gt;&gt; {\n  const response = await fetch(`/api/users/${id}`);\n  return response.json();\n}\n\n// 사용\nconst result = await fetchUser(1);\nconsole.log(result.data.name); // 타입 안전!\n</code></pre>\n<h2>결론</h2>\n<p>TypeScript를 잘 활용하면 코드의 안정성과 개발 생산성이 크게 향상됩니다.<br>타입 시스템을 제대로 이해하고 활용하는 것이 중요합니다! 🚀</p>\n",
    "rawContent": "\n# TypeScript 실전 팁 모음 💎\n\n실무에서 자주 사용하는 TypeScript 패턴과 팁들을 정리했습니다.\n\n## 1. 타입 가드 (Type Guards)\n\n런타임에서 타입을 좁혀나가는 방법입니다.\n\n```typescript\n// typeof 사용\nfunction padLeft(value: string, padding: string | number) {\n  if (typeof padding === \"number\") {\n    return Array(padding + 1).join(\" \") + value;\n  }\n  return padding + value;\n}\n\n// instanceof 사용\nclass Dog {\n  bark() { console.log(\"멍멍!\"); }\n}\n\nclass Cat {\n  meow() { console.log(\"야옹~\"); }\n}\n\nfunction makeSound(animal: Dog | Cat) {\n  if (animal instanceof Dog) {\n    animal.bark();\n  } else {\n    animal.meow();\n  }\n}\n\n// 사용자 정의 타입 가드\ninterface Fish {\n  swim: () => void;\n}\n\ninterface Bird {\n  fly: () => void;\n}\n\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined;\n}\n```\n\n## 2. 유틸리티 타입 활용\n\nTypeScript에서 제공하는 내장 유틸리티 타입들입니다.\n\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  age?: number;\n}\n\n// Partial - 모든 속성을 선택적으로\ntype PartialUser = Partial<User>;\n// { id?: number; name?: string; email?: string; age?: number }\n\n// Required - 모든 속성을 필수로\ntype RequiredUser = Required<User>;\n// { id: number; name: string; email: string; age: number }\n\n// Pick - 특정 속성만 선택\ntype UserBasic = Pick<User, 'id' | 'name'>;\n// { id: number; name: string }\n\n// Omit - 특정 속성 제외\ntype UserWithoutEmail = Omit<User, 'email'>;\n// { id: number; name: string; age?: number }\n\n// Record - 키-값 쌍 타입 생성\ntype PageInfo = Record<'home' | 'about' | 'contact', { title: string }>;\n// { home: { title: string }, about: { title: string }, contact: { title: string } }\n```\n\n## 3. 제네릭 활용\n\n재사용 가능한 컴포넌트를 만들 때 필수입니다.\n\n```typescript\n// 기본 제네릭 함수\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n\n// 배열 제네릭\nfunction getFirstElement<T>(arr: T[]): T | undefined {\n  return arr[0];\n}\n\n// 제약 조건이 있는 제네릭\ninterface Lengthwise {\n  length: number;\n}\n\nfunction logLength<T extends Lengthwise>(arg: T): void {\n  console.log(arg.length);\n}\n\n// 클래스에서 제네릭 사용\nclass DataStore<T> {\n  private data: T[] = [];\n\n  add(item: T): void {\n    this.data.push(item);\n  }\n\n  get(index: number): T | undefined {\n    return this.data[index];\n  }\n\n  getAll(): T[] {\n    return [...this.data];\n  }\n}\n\nconst numberStore = new DataStore<number>();\nnumberStore.add(1);\nnumberStore.add(2);\n```\n\n## 4. 고급 타입 패턴\n\n### Union vs Intersection\n\n```typescript\n// Union (|) - 둘 중 하나\ntype Status = 'idle' | 'loading' | 'success' | 'error';\n\n// Intersection (&) - 모두 포함\ntype Admin = User & {\n  permissions: string[];\n};\n```\n\n### Discriminated Union\n\n```typescript\ntype Shape = \n  | { kind: 'circle'; radius: number }\n  | { kind: 'square'; size: number }\n  | { kind: 'rectangle'; width: number; height: number };\n\nfunction area(shape: Shape): number {\n  switch (shape.kind) {\n    case 'circle':\n      return Math.PI * shape.radius ** 2;\n    case 'square':\n      return shape.size ** 2;\n    case 'rectangle':\n      return shape.width * shape.height;\n  }\n}\n```\n\n### Mapped Types\n\n```typescript\ntype ReadOnly<T> = {\n  readonly [P in keyof T]: T[P];\n};\n\ntype Nullable<T> = {\n  [P in keyof T]: T[P] | null;\n};\n\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n}\n\ntype ReadonlyProduct = ReadOnly<Product>;\ntype NullableProduct = Nullable<Product>;\n```\n\n## 5. 타입 추론 활용\n\n```typescript\n// 함수 반환 타입 추론\nconst createUser = () => ({\n  id: 1,\n  name: 'John',\n  email: 'john@example.com'\n});\n\ntype User = ReturnType<typeof createUser>;\n// { id: number; name: string; email: string }\n\n// 매개변수 타입 추론\nfunction greet(name: string) {\n  return `Hello, ${name}`;\n}\n\ntype GreetParams = Parameters<typeof greet>;\n// [name: string]\n```\n\n## 6. 실전 예제: API 응답 타입\n\n```typescript\ninterface ApiResponse<T> {\n  data: T;\n  status: number;\n  message: string;\n}\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nasync function fetchUser(id: number): Promise<ApiResponse<User>> {\n  const response = await fetch(`/api/users/${id}`);\n  return response.json();\n}\n\n// 사용\nconst result = await fetchUser(1);\nconsole.log(result.data.name); // 타입 안전!\n```\n\n## 결론\n\nTypeScript를 잘 활용하면 코드의 안정성과 개발 생산성이 크게 향상됩니다.\n타입 시스템을 제대로 이해하고 활용하는 것이 중요합니다! 🚀\n\n"
  },
  {
    "id": "2025-10-05-nodejs-express-api",
    "slug": "2025-10-05-nodejs-express-api",
    "title": "Node.js Express로 REST API 구축하기",
    "date": "2025-10-05",
    "category": "Framework",
    "subcategory": "Node.js",
    "tags": [
      "Node.js",
      "Express",
      "REST API",
      "Backend"
    ],
    "excerpt": "Express 프레임워크를 사용하여 RESTful API 서버를 구축하는 방법을 단계별로 알아봅니다.",
    "author": "Geon Lee",
    "content": "<h1>Node.js Express로 REST API 구축하기</h1>\n<p>Express는 Node.js에서 가장 인기 있는 웹 프레임워크로, RESTful API를 쉽고 빠르게 구축할 수 있게 해줍니다.</p>\n<h2>프로젝트 초기 설정</h2>\n<pre><code class=\"language-bash\"># 프로젝트 초기화\nmkdir my-api &amp;&amp; cd my-api\nnpm init -y\n\n# 필요한 패키지 설치\nnpm install express\nnpm install --save-dev nodemon typescript @types/express @types/node\n\n# TypeScript 설정\nnpx tsc --init\n</code></pre>\n<h2>기본 서버 설정</h2>\n<pre><code class=\"language-typescript\">import express, { Request, Response } from &#39;express&#39;;\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Middleware\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\n// 기본 라우트\napp.get(&#39;/&#39;, (req: Request, res: Response) =&gt; {\n  res.json({ message: &#39;API Server is running&#39; });\n});\n\napp.listen(PORT, () =&gt; {\n  console.log(`Server is running on port ${PORT}`);\n});\n</code></pre>\n<h2>REST API 구현</h2>\n<h3>User CRUD</h3>\n<pre><code class=\"language-typescript\">interface User {\n  id: number;\n  name: string;\n  email: string;\n  age: number;\n}\n\nlet users: User[] = [\n  { id: 1, name: &#39;John&#39;, email: &#39;john@example.com&#39;, age: 25 },\n  { id: 2, name: &#39;Jane&#39;, email: &#39;jane@example.com&#39;, age: 30 },\n];\n\n// GET /api/users - 전체 조회\napp.get(&#39;/api/users&#39;, (req: Request, res: Response) =&gt; {\n  res.json({ data: users, count: users.length });\n});\n\n// GET /api/users/:id - 단일 조회\napp.get(&#39;/api/users/:id&#39;, (req: Request, res: Response) =&gt; {\n  const id = parseInt(req.params.id);\n  const user = users.find(u =&gt; u.id === id);\n  \n  if (!user) {\n    return res.status(404).json({ error: &#39;User not found&#39; });\n  }\n  \n  res.json({ data: user });\n});\n\n// POST /api/users - 생성\napp.post(&#39;/api/users&#39;, (req: Request, res: Response) =&gt; {\n  const { name, email, age } = req.body;\n  \n  // Validation\n  if (!name || !email || !age) {\n    return res.status(400).json({ \n      error: &#39;Missing required fields&#39; \n    });\n  }\n  \n  const newUser: User = {\n    id: users.length + 1,\n    name,\n    email,\n    age,\n  };\n  \n  users.push(newUser);\n  res.status(201).json({ data: newUser });\n});\n\n// PUT /api/users/:id - 수정\napp.put(&#39;/api/users/:id&#39;, (req: Request, res: Response) =&gt; {\n  const id = parseInt(req.params.id);\n  const userIndex = users.findIndex(u =&gt; u.id === id);\n  \n  if (userIndex === -1) {\n    return res.status(404).json({ error: &#39;User not found&#39; });\n  }\n  \n  users[userIndex] = {\n    ...users[userIndex],\n    ...req.body,\n    id, // ID는 변경 불가\n  };\n  \n  res.json({ data: users[userIndex] });\n});\n\n// DELETE /api/users/:id - 삭제\napp.delete(&#39;/api/users/:id&#39;, (req: Request, res: Response) =&gt; {\n  const id = parseInt(req.params.id);\n  const userIndex = users.findIndex(u =&gt; u.id === id);\n  \n  if (userIndex === -1) {\n    return res.status(404).json({ error: &#39;User not found&#39; });\n  }\n  \n  users.splice(userIndex, 1);\n  res.status(204).send();\n});\n</code></pre>\n<h2>Middleware 활용</h2>\n<h3>Logger Middleware</h3>\n<pre><code class=\"language-typescript\">const logger = (req: Request, res: Response, next: Function) =&gt; {\n  console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);\n  next();\n};\n\napp.use(logger);\n</code></pre>\n<h3>Error Handler Middleware</h3>\n<pre><code class=\"language-typescript\">app.use((err: Error, req: Request, res: Response, next: Function) =&gt; {\n  console.error(err.stack);\n  res.status(500).json({ \n    error: &#39;Internal Server Error&#39;,\n    message: err.message \n  });\n});\n</code></pre>\n<h3>Authentication Middleware</h3>\n<pre><code class=\"language-typescript\">const authMiddleware = (req: Request, res: Response, next: Function) =&gt; {\n  const token = req.headers.authorization;\n  \n  if (!token) {\n    return res.status(401).json({ error: &#39;No token provided&#39; });\n  }\n  \n  // Token 검증 로직\n  try {\n    // verify token\n    next();\n  } catch (error) {\n    res.status(401).json({ error: &#39;Invalid token&#39; });\n  }\n};\n\n// 보호된 라우트에 적용\napp.get(&#39;/api/protected&#39;, authMiddleware, (req, res) =&gt; {\n  res.json({ message: &#39;This is protected&#39; });\n});\n</code></pre>\n<h2>Router 분리</h2>\n<h3>routes/users.ts</h3>\n<pre><code class=\"language-typescript\">import { Router } from &#39;express&#39;;\n\nconst router = Router();\n\nrouter.get(&#39;/&#39;, getAllUsers);\nrouter.get(&#39;/:id&#39;, getUser);\nrouter.post(&#39;/&#39;, createUser);\nrouter.put(&#39;/:id&#39;, updateUser);\nrouter.delete(&#39;/:id&#39;, deleteUser);\n\nexport default router;\n</code></pre>\n<h3>app.ts</h3>\n<pre><code class=\"language-typescript\">import userRoutes from &#39;./routes/users&#39;;\n\napp.use(&#39;/api/users&#39;, userRoutes);\n</code></pre>\n<h2>Validation</h2>\n<h3>express-validator 사용</h3>\n<pre><code class=\"language-typescript\">import { body, validationResult } from &#39;express-validator&#39;;\n\napp.post(&#39;/api/users&#39;,\n  [\n    body(&#39;email&#39;).isEmail().withMessage(&#39;Invalid email&#39;),\n    body(&#39;age&#39;).isInt({ min: 0, max: 120 }).withMessage(&#39;Invalid age&#39;),\n    body(&#39;name&#39;).trim().notEmpty().withMessage(&#39;Name is required&#39;),\n  ],\n  (req: Request, res: Response) =&gt; {\n    const errors = validationResult(req);\n    \n    if (!errors.isEmpty()) {\n      return res.status(400).json({ errors: errors.array() });\n    }\n    \n    // 정상 처리\n  }\n);\n</code></pre>\n<h2>데이터베이스 연동 (MongoDB)</h2>\n<pre><code class=\"language-typescript\">import mongoose from &#39;mongoose&#39;;\n\n// 연결\nmongoose.connect(&#39;mongodb://localhost:27017/mydb&#39;)\n  .then(() =&gt; console.log(&#39;MongoDB connected&#39;))\n  .catch(err =&gt; console.error(&#39;MongoDB connection error:&#39;, err));\n\n// 스키마 정의\nconst userSchema = new mongoose.Schema({\n  name: { type: String, required: true },\n  email: { type: String, required: true, unique: true },\n  age: { type: Number, required: true },\n}, { timestamps: true });\n\nconst User = mongoose.model(&#39;User&#39;, userSchema);\n\n// CRUD 작업\napp.get(&#39;/api/users&#39;, async (req, res) =&gt; {\n  try {\n    const users = await User.find();\n    res.json({ data: users });\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\napp.post(&#39;/api/users&#39;, async (req, res) =&gt; {\n  try {\n    const user = new User(req.body);\n    await user.save();\n    res.status(201).json({ data: user });\n  } catch (error) {\n    res.status(400).json({ error: error.message });\n  }\n});\n</code></pre>\n<h2>환경 변수 관리</h2>\n<h3>.env</h3>\n<pre><code>PORT=3000\nMONGODB_URI=mongodb://localhost:27017/mydb\nJWT_SECRET=your-secret-key\nNODE_ENV=development\n</code></pre>\n<h3>config.ts</h3>\n<pre><code class=\"language-typescript\">import dotenv from &#39;dotenv&#39;;\n\ndotenv.config();\n\nexport const config = {\n  port: process.env.PORT || 3000,\n  mongodbUri: process.env.MONGODB_URI,\n  jwtSecret: process.env.JWT_SECRET,\n  nodeEnv: process.env.NODE_ENV || &#39;development&#39;,\n};\n</code></pre>\n<h2>CORS 설정</h2>\n<pre><code class=\"language-typescript\">import cors from &#39;cors&#39;;\n\napp.use(cors({\n  origin: &#39;http://localhost:3000&#39;,\n  credentials: true,\n}));\n</code></pre>\n<h2>파일 업로드</h2>\n<pre><code class=\"language-typescript\">import multer from &#39;multer&#39;;\n\nconst storage = multer.diskStorage({\n  destination: (req, file, cb) =&gt; {\n    cb(null, &#39;uploads/&#39;);\n  },\n  filename: (req, file, cb) =&gt; {\n    const uniqueSuffix = Date.now() + &#39;-&#39; + Math.round(Math.random() * 1E9);\n    cb(null, uniqueSuffix + &#39;-&#39; + file.originalname);\n  }\n});\n\nconst upload = multer({ storage });\n\napp.post(&#39;/api/upload&#39;, upload.single(&#39;file&#39;), (req, res) =&gt; {\n  res.json({ \n    message: &#39;File uploaded&#39;,\n    file: req.file \n  });\n});\n</code></pre>\n<h2>성능 최적화</h2>\n<h3>압축</h3>\n<pre><code class=\"language-typescript\">import compression from &#39;compression&#39;;\n\napp.use(compression());\n</code></pre>\n<h3>Rate Limiting</h3>\n<pre><code class=\"language-typescript\">import rateLimit from &#39;express-rate-limit&#39;;\n\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15분\n  max: 100, // 최대 100 요청\n  message: &#39;Too many requests&#39;,\n});\n\napp.use(&#39;/api/&#39;, limiter);\n</code></pre>\n<h2>결론</h2>\n<p>Express는 간결하면서도 강력한 프레임워크로, RESTful API를 빠르게 구축할 수 있게 해줍니다.<br>미들웨어 시스템을 잘 활용하면 확장 가능하고 유지보수하기 쉬운 백엔드를 만들 수 있습니다! 🚀</p>\n",
    "rawContent": "\n# Node.js Express로 REST API 구축하기\n\nExpress는 Node.js에서 가장 인기 있는 웹 프레임워크로, RESTful API를 쉽고 빠르게 구축할 수 있게 해줍니다.\n\n## 프로젝트 초기 설정\n\n```bash\n# 프로젝트 초기화\nmkdir my-api && cd my-api\nnpm init -y\n\n# 필요한 패키지 설치\nnpm install express\nnpm install --save-dev nodemon typescript @types/express @types/node\n\n# TypeScript 설정\nnpx tsc --init\n```\n\n## 기본 서버 설정\n\n```typescript\nimport express, { Request, Response } from 'express';\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Middleware\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\n// 기본 라우트\napp.get('/', (req: Request, res: Response) => {\n  res.json({ message: 'API Server is running' });\n});\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n```\n\n## REST API 구현\n\n### User CRUD\n\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  age: number;\n}\n\nlet users: User[] = [\n  { id: 1, name: 'John', email: 'john@example.com', age: 25 },\n  { id: 2, name: 'Jane', email: 'jane@example.com', age: 30 },\n];\n\n// GET /api/users - 전체 조회\napp.get('/api/users', (req: Request, res: Response) => {\n  res.json({ data: users, count: users.length });\n});\n\n// GET /api/users/:id - 단일 조회\napp.get('/api/users/:id', (req: Request, res: Response) => {\n  const id = parseInt(req.params.id);\n  const user = users.find(u => u.id === id);\n  \n  if (!user) {\n    return res.status(404).json({ error: 'User not found' });\n  }\n  \n  res.json({ data: user });\n});\n\n// POST /api/users - 생성\napp.post('/api/users', (req: Request, res: Response) => {\n  const { name, email, age } = req.body;\n  \n  // Validation\n  if (!name || !email || !age) {\n    return res.status(400).json({ \n      error: 'Missing required fields' \n    });\n  }\n  \n  const newUser: User = {\n    id: users.length + 1,\n    name,\n    email,\n    age,\n  };\n  \n  users.push(newUser);\n  res.status(201).json({ data: newUser });\n});\n\n// PUT /api/users/:id - 수정\napp.put('/api/users/:id', (req: Request, res: Response) => {\n  const id = parseInt(req.params.id);\n  const userIndex = users.findIndex(u => u.id === id);\n  \n  if (userIndex === -1) {\n    return res.status(404).json({ error: 'User not found' });\n  }\n  \n  users[userIndex] = {\n    ...users[userIndex],\n    ...req.body,\n    id, // ID는 변경 불가\n  };\n  \n  res.json({ data: users[userIndex] });\n});\n\n// DELETE /api/users/:id - 삭제\napp.delete('/api/users/:id', (req: Request, res: Response) => {\n  const id = parseInt(req.params.id);\n  const userIndex = users.findIndex(u => u.id === id);\n  \n  if (userIndex === -1) {\n    return res.status(404).json({ error: 'User not found' });\n  }\n  \n  users.splice(userIndex, 1);\n  res.status(204).send();\n});\n```\n\n## Middleware 활용\n\n### Logger Middleware\n\n```typescript\nconst logger = (req: Request, res: Response, next: Function) => {\n  console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);\n  next();\n};\n\napp.use(logger);\n```\n\n### Error Handler Middleware\n\n```typescript\napp.use((err: Error, req: Request, res: Response, next: Function) => {\n  console.error(err.stack);\n  res.status(500).json({ \n    error: 'Internal Server Error',\n    message: err.message \n  });\n});\n```\n\n### Authentication Middleware\n\n```typescript\nconst authMiddleware = (req: Request, res: Response, next: Function) => {\n  const token = req.headers.authorization;\n  \n  if (!token) {\n    return res.status(401).json({ error: 'No token provided' });\n  }\n  \n  // Token 검증 로직\n  try {\n    // verify token\n    next();\n  } catch (error) {\n    res.status(401).json({ error: 'Invalid token' });\n  }\n};\n\n// 보호된 라우트에 적용\napp.get('/api/protected', authMiddleware, (req, res) => {\n  res.json({ message: 'This is protected' });\n});\n```\n\n## Router 분리\n\n### routes/users.ts\n\n```typescript\nimport { Router } from 'express';\n\nconst router = Router();\n\nrouter.get('/', getAllUsers);\nrouter.get('/:id', getUser);\nrouter.post('/', createUser);\nrouter.put('/:id', updateUser);\nrouter.delete('/:id', deleteUser);\n\nexport default router;\n```\n\n### app.ts\n\n```typescript\nimport userRoutes from './routes/users';\n\napp.use('/api/users', userRoutes);\n```\n\n## Validation\n\n### express-validator 사용\n\n```typescript\nimport { body, validationResult } from 'express-validator';\n\napp.post('/api/users',\n  [\n    body('email').isEmail().withMessage('Invalid email'),\n    body('age').isInt({ min: 0, max: 120 }).withMessage('Invalid age'),\n    body('name').trim().notEmpty().withMessage('Name is required'),\n  ],\n  (req: Request, res: Response) => {\n    const errors = validationResult(req);\n    \n    if (!errors.isEmpty()) {\n      return res.status(400).json({ errors: errors.array() });\n    }\n    \n    // 정상 처리\n  }\n);\n```\n\n## 데이터베이스 연동 (MongoDB)\n\n```typescript\nimport mongoose from 'mongoose';\n\n// 연결\nmongoose.connect('mongodb://localhost:27017/mydb')\n  .then(() => console.log('MongoDB connected'))\n  .catch(err => console.error('MongoDB connection error:', err));\n\n// 스키마 정의\nconst userSchema = new mongoose.Schema({\n  name: { type: String, required: true },\n  email: { type: String, required: true, unique: true },\n  age: { type: Number, required: true },\n}, { timestamps: true });\n\nconst User = mongoose.model('User', userSchema);\n\n// CRUD 작업\napp.get('/api/users', async (req, res) => {\n  try {\n    const users = await User.find();\n    res.json({ data: users });\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\napp.post('/api/users', async (req, res) => {\n  try {\n    const user = new User(req.body);\n    await user.save();\n    res.status(201).json({ data: user });\n  } catch (error) {\n    res.status(400).json({ error: error.message });\n  }\n});\n```\n\n## 환경 변수 관리\n\n### .env\n\n```\nPORT=3000\nMONGODB_URI=mongodb://localhost:27017/mydb\nJWT_SECRET=your-secret-key\nNODE_ENV=development\n```\n\n### config.ts\n\n```typescript\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nexport const config = {\n  port: process.env.PORT || 3000,\n  mongodbUri: process.env.MONGODB_URI,\n  jwtSecret: process.env.JWT_SECRET,\n  nodeEnv: process.env.NODE_ENV || 'development',\n};\n```\n\n## CORS 설정\n\n```typescript\nimport cors from 'cors';\n\napp.use(cors({\n  origin: 'http://localhost:3000',\n  credentials: true,\n}));\n```\n\n## 파일 업로드\n\n```typescript\nimport multer from 'multer';\n\nconst storage = multer.diskStorage({\n  destination: (req, file, cb) => {\n    cb(null, 'uploads/');\n  },\n  filename: (req, file, cb) => {\n    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\n    cb(null, uniqueSuffix + '-' + file.originalname);\n  }\n});\n\nconst upload = multer({ storage });\n\napp.post('/api/upload', upload.single('file'), (req, res) => {\n  res.json({ \n    message: 'File uploaded',\n    file: req.file \n  });\n});\n```\n\n## 성능 최적화\n\n### 압축\n\n```typescript\nimport compression from 'compression';\n\napp.use(compression());\n```\n\n### Rate Limiting\n\n```typescript\nimport rateLimit from 'express-rate-limit';\n\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15분\n  max: 100, // 최대 100 요청\n  message: 'Too many requests',\n});\n\napp.use('/api/', limiter);\n```\n\n## 결론\n\nExpress는 간결하면서도 강력한 프레임워크로, RESTful API를 빠르게 구축할 수 있게 해줍니다.\n미들웨어 시스템을 잘 활용하면 확장 가능하고 유지보수하기 쉬운 백엔드를 만들 수 있습니다! 🚀\n\n"
  },
  {
    "id": "2025-10-04-spring-boot-jpa",
    "slug": "2025-10-04-spring-boot-jpa",
    "title": "Spring Boot JPA 실전 가이드",
    "date": "2025-10-04",
    "category": "Framework",
    "subcategory": "Spring",
    "tags": [
      "Spring Boot",
      "JPA",
      "Hibernate",
      "Database"
    ],
    "excerpt": "Spring Boot와 JPA를 활용하여 효율적인 데이터 접근 계층을 구축하는 방법을 알아봅니다.",
    "author": "Geon Lee",
    "content": "<h1>Spring Boot JPA 실전 가이드</h1>\n<p>Spring Data JPA는 JPA 기반 데이터 접근 계층을 쉽게 구축할 수 있게 해주는 강력한 도구입니다.</p>\n<h2>JPA란?</h2>\n<p>JPA (Java Persistence API)는 자바 ORM 기술의 표준으로, 객체와 관계형 데이터베이스 간의 매핑을 처리합니다.</p>\n<h2>프로젝트 설정</h2>\n<h3>build.gradle</h3>\n<pre><code class=\"language-gradle\">dependencies {\n    implementation &#39;org.springframework.boot:spring-boot-starter-data-jpa&#39;\n    implementation &#39;org.springframework.boot:spring-boot-starter-web&#39;\n    runtimeOnly &#39;com.h2database:h2&#39;\n    // 또는 runtimeOnly &#39;mysql:mysql-connector-java&#39;\n}\n</code></pre>\n<h3>application.yml</h3>\n<pre><code class=\"language-yaml\">spring:\n  datasource:\n    url: jdbc:h2:mem:testdb\n    driver-class-name: org.h2.Driver\n    username: sa\n    password:\n  jpa:\n    hibernate:\n      ddl-auto: create\n    show-sql: true\n    properties:\n      hibernate:\n        format_sql: true\n</code></pre>\n<h2>Entity 정의</h2>\n<pre><code class=\"language-java\">@Entity\n@Table(name = &quot;users&quot;)\n@Getter @Setter\n@NoArgsConstructor\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @Column(nullable = false, length = 50)\n    private String name;\n    \n    @Column(unique = true, nullable = false)\n    private String email;\n    \n    @Column(nullable = false)\n    private Integer age;\n    \n    @CreatedDate\n    @Column(updatable = false)\n    private LocalDateTime createdAt;\n    \n    @LastModifiedDate\n    private LocalDateTime updatedAt;\n    \n    @Builder\n    public User(String name, String email, Integer age) {\n        this.name = name;\n        this.email = email;\n        this.age = age;\n    }\n}\n</code></pre>\n<h2>Repository 인터페이스</h2>\n<pre><code class=\"language-java\">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {\n    // 메소드 이름으로 쿼리 생성\n    Optional&lt;User&gt; findByEmail(String email);\n    \n    List&lt;User&gt; findByAgeBetween(int start, int end);\n    \n    List&lt;User&gt; findByNameContaining(String keyword);\n    \n    // @Query 어노테이션 사용\n    @Query(&quot;SELECT u FROM User u WHERE u.age &gt;= :age&quot;)\n    List&lt;User&gt; findAdults(@Param(&quot;age&quot;) int age);\n    \n    // Native Query\n    @Query(value = &quot;SELECT * FROM users WHERE email LIKE %:domain&quot;, \n           nativeQuery = true)\n    List&lt;User&gt; findByEmailDomain(@Param(&quot;domain&quot;) String domain);\n    \n    // Update Query\n    @Modifying\n    @Query(&quot;UPDATE User u SET u.age = :age WHERE u.id = :id&quot;)\n    int updateAge(@Param(&quot;id&quot;) Long id, @Param(&quot;age&quot;) int age);\n}\n</code></pre>\n<h2>Service 계층</h2>\n<pre><code class=\"language-java\">@Service\n@RequiredArgsConstructor\n@Transactional(readOnly = true)\npublic class UserService {\n    private final UserRepository userRepository;\n    \n    @Transactional\n    public User createUser(UserCreateRequest request) {\n        User user = User.builder()\n            .name(request.getName())\n            .email(request.getEmail())\n            .age(request.getAge())\n            .build();\n        return userRepository.save(user);\n    }\n    \n    public User getUser(Long id) {\n        return userRepository.findById(id)\n            .orElseThrow(() -&gt; new EntityNotFoundException(&quot;User not found&quot;));\n    }\n    \n    public List&lt;User&gt; getAllUsers() {\n        return userRepository.findAll();\n    }\n    \n    @Transactional\n    public User updateUser(Long id, UserUpdateRequest request) {\n        User user = getUser(id);\n        user.setName(request.getName());\n        user.setAge(request.getAge());\n        return user; // 더티 체킹으로 자동 업데이트\n    }\n    \n    @Transactional\n    public void deleteUser(Long id) {\n        userRepository.deleteById(id);\n    }\n}\n</code></pre>\n<h2>연관관계 매핑</h2>\n<h3>OneToMany / ManyToOne</h3>\n<pre><code class=\"language-java\">@Entity\npublic class Post {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    private String title;\n    private String content;\n    \n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = &quot;user_id&quot;)\n    private User user;\n    \n    @OneToMany(mappedBy = &quot;post&quot;, cascade = CascadeType.ALL, \n               orphanRemoval = true)\n    private List&lt;Comment&gt; comments = new ArrayList&lt;&gt;();\n    \n    public void addComment(Comment comment) {\n        comments.add(comment);\n        comment.setPost(this);\n    }\n}\n</code></pre>\n<h3>ManyToMany</h3>\n<pre><code class=\"language-java\">@Entity\npublic class Student {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    private String name;\n    \n    @ManyToMany\n    @JoinTable(\n        name = &quot;student_course&quot;,\n        joinColumns = @JoinColumn(name = &quot;student_id&quot;),\n        inverseJoinColumns = @JoinColumn(name = &quot;course_id&quot;)\n    )\n    private Set&lt;Course&gt; courses = new HashSet&lt;&gt;();\n}\n</code></pre>\n<h2>페이징과 정렬</h2>\n<pre><code class=\"language-java\">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {\n    Page&lt;User&gt; findByAgeGreaterThan(int age, Pageable pageable);\n}\n\n// Service에서 사용\npublic Page&lt;User&gt; getAdultUsers(int page, int size) {\n    Pageable pageable = PageRequest.of(page, size, \n        Sort.by(&quot;createdAt&quot;).descending());\n    return userRepository.findByAgeGreaterThan(18, pageable);\n}\n</code></pre>\n<h2>QueryDSL 활용</h2>\n<h3>설정</h3>\n<pre><code class=\"language-gradle\">dependencies {\n    implementation &#39;com.querydsl:querydsl-jpa&#39;\n    annotationProcessor &#39;com.querydsl:querydsl-apt:5.0.0:jpa&#39;\n    annotationProcessor &#39;jakarta.persistence:jakarta.persistence-api&#39;\n}\n</code></pre>\n<h3>사용</h3>\n<pre><code class=\"language-java\">@Repository\n@RequiredArgsConstructor\npublic class UserRepositoryCustomImpl implements UserRepositoryCustom {\n    private final JPAQueryFactory queryFactory;\n    \n    @Override\n    public List&lt;User&gt; findByCondition(UserSearchCondition condition) {\n        return queryFactory\n            .selectFrom(QUser.user)\n            .where(\n                nameContains(condition.getName()),\n                ageGoe(condition.getMinAge()),\n                ageLoe(condition.getMaxAge())\n            )\n            .orderBy(QUser.user.createdAt.desc())\n            .fetch();\n    }\n    \n    private BooleanExpression nameContains(String name) {\n        return name != null ? QUser.user.name.contains(name) : null;\n    }\n    \n    private BooleanExpression ageGoe(Integer age) {\n        return age != null ? QUser.user.age.goe(age) : null;\n    }\n    \n    private BooleanExpression ageLoe(Integer age) {\n        return age != null ? QUser.user.age.loe(age) : null;\n    }\n}\n</code></pre>\n<h2>N+1 문제 해결</h2>\n<h3>Fetch Join</h3>\n<pre><code class=\"language-java\">@Query(&quot;SELECT u FROM User u JOIN FETCH u.posts WHERE u.id = :id&quot;)\nOptional&lt;User&gt; findByIdWithPosts(@Param(&quot;id&quot;) Long id);\n</code></pre>\n<h3>EntityGraph</h3>\n<pre><code class=\"language-java\">@EntityGraph(attributePaths = {&quot;posts&quot;, &quot;comments&quot;})\n@Query(&quot;SELECT u FROM User u WHERE u.id = :id&quot;)\nOptional&lt;User&gt; findByIdWithDetails(@Param(&quot;id&quot;) Long id);\n</code></pre>\n<h3>Batch Size</h3>\n<pre><code class=\"language-yaml\">spring:\n  jpa:\n    properties:\n      hibernate:\n        default_batch_fetch_size: 100\n</code></pre>\n<h2>성능 최적화 팁</h2>\n<ol>\n<li><strong>FetchType.LAZY 사용</strong>: 즉시 로딩 피하기</li>\n<li><strong>적절한 인덱스</strong>: <code>@Table(indexes = @Index(...))</code></li>\n<li><strong>@Transactional(readOnly = true)</strong>: 읽기 전용 최적화</li>\n<li><strong>Batch Insert</strong>: <code>spring.jpa.properties.hibernate.jdbc.batch_size</code></li>\n<li><strong>DTO 프로젝션</strong>: 필요한 필드만 조회</li>\n</ol>\n<h2>결론</h2>\n<p>Spring Data JPA는 반복적인 CRUD 작업을 획기적으로 줄여주고, 개발자가 비즈니스 로직에 집중할 수 있게 해줍니다.<br>적절한 최적화와 함께 사용하면 강력한 데이터 접근 계층을 구축할 수 있습니다! 🚀</p>\n",
    "rawContent": "\n# Spring Boot JPA 실전 가이드\n\nSpring Data JPA는 JPA 기반 데이터 접근 계층을 쉽게 구축할 수 있게 해주는 강력한 도구입니다.\n\n## JPA란?\n\nJPA (Java Persistence API)는 자바 ORM 기술의 표준으로, 객체와 관계형 데이터베이스 간의 매핑을 처리합니다.\n\n## 프로젝트 설정\n\n### build.gradle\n\n```gradle\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'\n    implementation 'org.springframework.boot:spring-boot-starter-web'\n    runtimeOnly 'com.h2database:h2'\n    // 또는 runtimeOnly 'mysql:mysql-connector-java'\n}\n```\n\n### application.yml\n\n```yaml\nspring:\n  datasource:\n    url: jdbc:h2:mem:testdb\n    driver-class-name: org.h2.Driver\n    username: sa\n    password:\n  jpa:\n    hibernate:\n      ddl-auto: create\n    show-sql: true\n    properties:\n      hibernate:\n        format_sql: true\n```\n\n## Entity 정의\n\n```java\n@Entity\n@Table(name = \"users\")\n@Getter @Setter\n@NoArgsConstructor\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @Column(nullable = false, length = 50)\n    private String name;\n    \n    @Column(unique = true, nullable = false)\n    private String email;\n    \n    @Column(nullable = false)\n    private Integer age;\n    \n    @CreatedDate\n    @Column(updatable = false)\n    private LocalDateTime createdAt;\n    \n    @LastModifiedDate\n    private LocalDateTime updatedAt;\n    \n    @Builder\n    public User(String name, String email, Integer age) {\n        this.name = name;\n        this.email = email;\n        this.age = age;\n    }\n}\n```\n\n## Repository 인터페이스\n\n```java\npublic interface UserRepository extends JpaRepository<User, Long> {\n    // 메소드 이름으로 쿼리 생성\n    Optional<User> findByEmail(String email);\n    \n    List<User> findByAgeBetween(int start, int end);\n    \n    List<User> findByNameContaining(String keyword);\n    \n    // @Query 어노테이션 사용\n    @Query(\"SELECT u FROM User u WHERE u.age >= :age\")\n    List<User> findAdults(@Param(\"age\") int age);\n    \n    // Native Query\n    @Query(value = \"SELECT * FROM users WHERE email LIKE %:domain\", \n           nativeQuery = true)\n    List<User> findByEmailDomain(@Param(\"domain\") String domain);\n    \n    // Update Query\n    @Modifying\n    @Query(\"UPDATE User u SET u.age = :age WHERE u.id = :id\")\n    int updateAge(@Param(\"id\") Long id, @Param(\"age\") int age);\n}\n```\n\n## Service 계층\n\n```java\n@Service\n@RequiredArgsConstructor\n@Transactional(readOnly = true)\npublic class UserService {\n    private final UserRepository userRepository;\n    \n    @Transactional\n    public User createUser(UserCreateRequest request) {\n        User user = User.builder()\n            .name(request.getName())\n            .email(request.getEmail())\n            .age(request.getAge())\n            .build();\n        return userRepository.save(user);\n    }\n    \n    public User getUser(Long id) {\n        return userRepository.findById(id)\n            .orElseThrow(() -> new EntityNotFoundException(\"User not found\"));\n    }\n    \n    public List<User> getAllUsers() {\n        return userRepository.findAll();\n    }\n    \n    @Transactional\n    public User updateUser(Long id, UserUpdateRequest request) {\n        User user = getUser(id);\n        user.setName(request.getName());\n        user.setAge(request.getAge());\n        return user; // 더티 체킹으로 자동 업데이트\n    }\n    \n    @Transactional\n    public void deleteUser(Long id) {\n        userRepository.deleteById(id);\n    }\n}\n```\n\n## 연관관계 매핑\n\n### OneToMany / ManyToOne\n\n```java\n@Entity\npublic class Post {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    private String title;\n    private String content;\n    \n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"user_id\")\n    private User user;\n    \n    @OneToMany(mappedBy = \"post\", cascade = CascadeType.ALL, \n               orphanRemoval = true)\n    private List<Comment> comments = new ArrayList<>();\n    \n    public void addComment(Comment comment) {\n        comments.add(comment);\n        comment.setPost(this);\n    }\n}\n```\n\n### ManyToMany\n\n```java\n@Entity\npublic class Student {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    private String name;\n    \n    @ManyToMany\n    @JoinTable(\n        name = \"student_course\",\n        joinColumns = @JoinColumn(name = \"student_id\"),\n        inverseJoinColumns = @JoinColumn(name = \"course_id\")\n    )\n    private Set<Course> courses = new HashSet<>();\n}\n```\n\n## 페이징과 정렬\n\n```java\npublic interface UserRepository extends JpaRepository<User, Long> {\n    Page<User> findByAgeGreaterThan(int age, Pageable pageable);\n}\n\n// Service에서 사용\npublic Page<User> getAdultUsers(int page, int size) {\n    Pageable pageable = PageRequest.of(page, size, \n        Sort.by(\"createdAt\").descending());\n    return userRepository.findByAgeGreaterThan(18, pageable);\n}\n```\n\n## QueryDSL 활용\n\n### 설정\n\n```gradle\ndependencies {\n    implementation 'com.querydsl:querydsl-jpa'\n    annotationProcessor 'com.querydsl:querydsl-apt:5.0.0:jpa'\n    annotationProcessor 'jakarta.persistence:jakarta.persistence-api'\n}\n```\n\n### 사용\n\n```java\n@Repository\n@RequiredArgsConstructor\npublic class UserRepositoryCustomImpl implements UserRepositoryCustom {\n    private final JPAQueryFactory queryFactory;\n    \n    @Override\n    public List<User> findByCondition(UserSearchCondition condition) {\n        return queryFactory\n            .selectFrom(QUser.user)\n            .where(\n                nameContains(condition.getName()),\n                ageGoe(condition.getMinAge()),\n                ageLoe(condition.getMaxAge())\n            )\n            .orderBy(QUser.user.createdAt.desc())\n            .fetch();\n    }\n    \n    private BooleanExpression nameContains(String name) {\n        return name != null ? QUser.user.name.contains(name) : null;\n    }\n    \n    private BooleanExpression ageGoe(Integer age) {\n        return age != null ? QUser.user.age.goe(age) : null;\n    }\n    \n    private BooleanExpression ageLoe(Integer age) {\n        return age != null ? QUser.user.age.loe(age) : null;\n    }\n}\n```\n\n## N+1 문제 해결\n\n### Fetch Join\n\n```java\n@Query(\"SELECT u FROM User u JOIN FETCH u.posts WHERE u.id = :id\")\nOptional<User> findByIdWithPosts(@Param(\"id\") Long id);\n```\n\n### EntityGraph\n\n```java\n@EntityGraph(attributePaths = {\"posts\", \"comments\"})\n@Query(\"SELECT u FROM User u WHERE u.id = :id\")\nOptional<User> findByIdWithDetails(@Param(\"id\") Long id);\n```\n\n### Batch Size\n\n```yaml\nspring:\n  jpa:\n    properties:\n      hibernate:\n        default_batch_fetch_size: 100\n```\n\n## 성능 최적화 팁\n\n1. **FetchType.LAZY 사용**: 즉시 로딩 피하기\n2. **적절한 인덱스**: `@Table(indexes = @Index(...))`\n3. **@Transactional(readOnly = true)**: 읽기 전용 최적화\n4. **Batch Insert**: `spring.jpa.properties.hibernate.jdbc.batch_size`\n5. **DTO 프로젝션**: 필요한 필드만 조회\n\n## 결론\n\nSpring Data JPA는 반복적인 CRUD 작업을 획기적으로 줄여주고, 개발자가 비즈니스 로직에 집중할 수 있게 해줍니다.\n적절한 최적화와 함께 사용하면 강력한 데이터 접근 계층을 구축할 수 있습니다! 🚀\n\n"
  },
  {
    "id": "2025-10-03-python-decorator",
    "slug": "2025-10-03-python-decorator",
    "title": "Python Decorator 완전 정복",
    "date": "2025-10-03",
    "category": "Language",
    "subcategory": "Python",
    "tags": [
      "Python",
      "Decorator",
      "고급 문법"
    ],
    "excerpt": "Python의 강력한 기능 중 하나인 Decorator를 이해하고 실전에서 활용하는 방법을 배워봅니다.",
    "author": "Geon Lee",
    "content": "<h1>Python Decorator 완전 정복</h1>\n<p>Decorator는 Python의 강력한 기능으로, 함수나 클래스의 동작을 수정하거나 확장할 수 있게 해줍니다.</p>\n<h2>Decorator란?</h2>\n<p>Decorator는 다른 함수를 감싸서 그 함수의 동작을 수정하는 함수입니다.</p>\n<pre><code class=\"language-python\">@decorator\ndef my_function():\n    pass\n\n# 위 코드는 아래와 같습니다\ndef my_function():\n    pass\nmy_function = decorator(my_function)\n</code></pre>\n<h2>기본 Decorator</h2>\n<pre><code class=\"language-python\">def simple_decorator(func):\n    def wrapper():\n        print(&quot;함수 실행 전&quot;)\n        func()\n        print(&quot;함수 실행 후&quot;)\n    return wrapper\n\n@simple_decorator\ndef say_hello():\n    print(&quot;Hello!&quot;)\n\nsay_hello()\n# 출력:\n# 함수 실행 전\n# Hello!\n# 함수 실행 후\n</code></pre>\n<h2>인자를 받는 Decorator</h2>\n<pre><code class=\"language-python\">def decorator_with_args(func):\n    def wrapper(*args, **kwargs):\n        print(f&quot;인자: {args}, {kwargs}&quot;)\n        result = func(*args, **kwargs)\n        print(f&quot;반환값: {result}&quot;)\n        return result\n    return wrapper\n\n@decorator_with_args\ndef add(a, b):\n    return a + b\n\nadd(3, 5)\n# 출력:\n# 인자: (3, 5), {}\n# 반환값: 8\n</code></pre>\n<h2>실전 예제</h2>\n<h3>1. 실행 시간 측정</h3>\n<pre><code class=\"language-python\">import time\nfrom functools import wraps\n\ndef timer(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        end = time.time()\n        print(f&quot;{func.__name__} 실행 시간: {end - start:.4f}초&quot;)\n        return result\n    return wrapper\n\n@timer\ndef slow_function():\n    time.sleep(2)\n    return &quot;완료&quot;\n</code></pre>\n<h3>2. 로깅</h3>\n<pre><code class=\"language-python\">import logging\n\ndef log(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        logging.info(f&quot;{func.__name__} 호출됨&quot;)\n        try:\n            result = func(*args, **kwargs)\n            logging.info(f&quot;{func.__name__} 성공&quot;)\n            return result\n        except Exception as e:\n            logging.error(f&quot;{func.__name__} 실패: {e}&quot;)\n            raise\n    return wrapper\n\n@log\ndef divide(a, b):\n    return a / b\n</code></pre>\n<h3>3. 캐싱</h3>\n<pre><code class=\"language-python\">def memoize(func):\n    cache = {}\n    \n    @wraps(func)\n    def wrapper(*args):\n        if args in cache:\n            print(f&quot;캐시에서 반환: {args}&quot;)\n            return cache[args]\n        result = func(*args)\n        cache[args] = result\n        return result\n    return wrapper\n\n@memoize\ndef fibonacci(n):\n    if n &lt; 2:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n</code></pre>\n<h2>매개변수를 받는 Decorator</h2>\n<pre><code class=\"language-python\">def repeat(times):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            for _ in range(times):\n                result = func(*args, **kwargs)\n            return result\n        return wrapper\n    return decorator\n\n@repeat(times=3)\ndef greet(name):\n    print(f&quot;Hello, {name}!&quot;)\n\ngreet(&quot;World&quot;)\n# 출력:\n# Hello, World!\n# Hello, World!\n# Hello, World!\n</code></pre>\n<h2>클래스 기반 Decorator</h2>\n<pre><code class=\"language-python\">class CountCalls:\n    def __init__(self, func):\n        self.func = func\n        self.count = 0\n    \n    def __call__(self, *args, **kwargs):\n        self.count += 1\n        print(f&quot;호출 횟수: {self.count}&quot;)\n        return self.func(*args, **kwargs)\n\n@CountCalls\ndef say_hello():\n    print(&quot;Hello!&quot;)\n</code></pre>\n<h2>여러 Decorator 사용</h2>\n<pre><code class=\"language-python\">@decorator1\n@decorator2\n@decorator3\ndef my_function():\n    pass\n\n# 실행 순서: decorator3 -&gt; decorator2 -&gt; decorator1\n</code></pre>\n<h2>실전 활용: API 인증</h2>\n<pre><code class=\"language-python\">from functools import wraps\n\ndef require_auth(func):\n    @wraps(func)\n    def wrapper(request, *args, **kwargs):\n        token = request.headers.get(&#39;Authorization&#39;)\n        if not token or not validate_token(token):\n            return {&quot;error&quot;: &quot;Unauthorized&quot;}, 401\n        return func(request, *args, **kwargs)\n    return wrapper\n\n@require_auth\ndef get_user_data(request):\n    return {&quot;user&quot;: &quot;data&quot;}\n</code></pre>\n<h2>주의사항</h2>\n<h3>1. functools.wraps 사용</h3>\n<pre><code class=\"language-python\">from functools import wraps\n\ndef my_decorator(func):\n    @wraps(func)  # 원본 함수의 메타데이터 보존\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n    return wrapper\n</code></pre>\n<h3>2. 클로저 변수 주의</h3>\n<pre><code class=\"language-python\">def buggy_decorator():\n    count = 0  # 이 변수는 변경할 수 없음\n    \n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            nonlocal count  # nonlocal 키워드 필요\n            count += 1\n            return func(*args, **kwargs)\n        return wrapper\n    return decorator\n</code></pre>\n<h2>결론</h2>\n<p>Decorator는 코드의 재사용성을 높이고, 횡단 관심사(로깅, 인증, 캐싱 등)를 깔끔하게 처리할 수 있게 해줍니다.<br>적절히 활용하면 더 우아하고 유지보수하기 쉬운 코드를 작성할 수 있습니다! 🐍</p>\n",
    "rawContent": "\n# Python Decorator 완전 정복\n\nDecorator는 Python의 강력한 기능으로, 함수나 클래스의 동작을 수정하거나 확장할 수 있게 해줍니다.\n\n## Decorator란?\n\nDecorator는 다른 함수를 감싸서 그 함수의 동작을 수정하는 함수입니다.\n\n```python\n@decorator\ndef my_function():\n    pass\n\n# 위 코드는 아래와 같습니다\ndef my_function():\n    pass\nmy_function = decorator(my_function)\n```\n\n## 기본 Decorator\n\n```python\ndef simple_decorator(func):\n    def wrapper():\n        print(\"함수 실행 전\")\n        func()\n        print(\"함수 실행 후\")\n    return wrapper\n\n@simple_decorator\ndef say_hello():\n    print(\"Hello!\")\n\nsay_hello()\n# 출력:\n# 함수 실행 전\n# Hello!\n# 함수 실행 후\n```\n\n## 인자를 받는 Decorator\n\n```python\ndef decorator_with_args(func):\n    def wrapper(*args, **kwargs):\n        print(f\"인자: {args}, {kwargs}\")\n        result = func(*args, **kwargs)\n        print(f\"반환값: {result}\")\n        return result\n    return wrapper\n\n@decorator_with_args\ndef add(a, b):\n    return a + b\n\nadd(3, 5)\n# 출력:\n# 인자: (3, 5), {}\n# 반환값: 8\n```\n\n## 실전 예제\n\n### 1. 실행 시간 측정\n\n```python\nimport time\nfrom functools import wraps\n\ndef timer(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        end = time.time()\n        print(f\"{func.__name__} 실행 시간: {end - start:.4f}초\")\n        return result\n    return wrapper\n\n@timer\ndef slow_function():\n    time.sleep(2)\n    return \"완료\"\n```\n\n### 2. 로깅\n\n```python\nimport logging\n\ndef log(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        logging.info(f\"{func.__name__} 호출됨\")\n        try:\n            result = func(*args, **kwargs)\n            logging.info(f\"{func.__name__} 성공\")\n            return result\n        except Exception as e:\n            logging.error(f\"{func.__name__} 실패: {e}\")\n            raise\n    return wrapper\n\n@log\ndef divide(a, b):\n    return a / b\n```\n\n### 3. 캐싱\n\n```python\ndef memoize(func):\n    cache = {}\n    \n    @wraps(func)\n    def wrapper(*args):\n        if args in cache:\n            print(f\"캐시에서 반환: {args}\")\n            return cache[args]\n        result = func(*args)\n        cache[args] = result\n        return result\n    return wrapper\n\n@memoize\ndef fibonacci(n):\n    if n < 2:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n```\n\n## 매개변수를 받는 Decorator\n\n```python\ndef repeat(times):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            for _ in range(times):\n                result = func(*args, **kwargs)\n            return result\n        return wrapper\n    return decorator\n\n@repeat(times=3)\ndef greet(name):\n    print(f\"Hello, {name}!\")\n\ngreet(\"World\")\n# 출력:\n# Hello, World!\n# Hello, World!\n# Hello, World!\n```\n\n## 클래스 기반 Decorator\n\n```python\nclass CountCalls:\n    def __init__(self, func):\n        self.func = func\n        self.count = 0\n    \n    def __call__(self, *args, **kwargs):\n        self.count += 1\n        print(f\"호출 횟수: {self.count}\")\n        return self.func(*args, **kwargs)\n\n@CountCalls\ndef say_hello():\n    print(\"Hello!\")\n```\n\n## 여러 Decorator 사용\n\n```python\n@decorator1\n@decorator2\n@decorator3\ndef my_function():\n    pass\n\n# 실행 순서: decorator3 -> decorator2 -> decorator1\n```\n\n## 실전 활용: API 인증\n\n```python\nfrom functools import wraps\n\ndef require_auth(func):\n    @wraps(func)\n    def wrapper(request, *args, **kwargs):\n        token = request.headers.get('Authorization')\n        if not token or not validate_token(token):\n            return {\"error\": \"Unauthorized\"}, 401\n        return func(request, *args, **kwargs)\n    return wrapper\n\n@require_auth\ndef get_user_data(request):\n    return {\"user\": \"data\"}\n```\n\n## 주의사항\n\n### 1. functools.wraps 사용\n\n```python\nfrom functools import wraps\n\ndef my_decorator(func):\n    @wraps(func)  # 원본 함수의 메타데이터 보존\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n    return wrapper\n```\n\n### 2. 클로저 변수 주의\n\n```python\ndef buggy_decorator():\n    count = 0  # 이 변수는 변경할 수 없음\n    \n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            nonlocal count  # nonlocal 키워드 필요\n            count += 1\n            return func(*args, **kwargs)\n        return wrapper\n    return decorator\n```\n\n## 결론\n\nDecorator는 코드의 재사용성을 높이고, 횡단 관심사(로깅, 인증, 캐싱 등)를 깔끔하게 처리할 수 있게 해줍니다.\n적절히 활용하면 더 우아하고 유지보수하기 쉬운 코드를 작성할 수 있습니다! 🐍\n\n"
  },
  {
    "id": "2025-10-02-java-stream-api",
    "slug": "2025-10-02-java-stream-api",
    "title": "Java Stream API 완벽 가이드",
    "date": "2025-10-02",
    "category": "Language",
    "subcategory": "Java",
    "tags": [
      "Java",
      "Stream",
      "함수형 프로그래밍"
    ],
    "excerpt": "Java 8에 도입된 Stream API를 활용하여 컬렉션을 효율적으로 처리하는 방법을 알아봅니다.",
    "author": "Geon Lee",
    "content": "<h1>Java Stream API 완벽 가이드</h1>\n<p>Java 8부터 도입된 Stream API는 컬렉션 데이터를 함수형 스타일로 처리할 수 있게 해줍니다.</p>\n<h2>Stream이란?</h2>\n<p>Stream은 데이터의 흐름을 나타내는 객체로, 컬렉션의 요소를 하나씩 참조하여 람다식으로 처리할 수 있는 기능입니다.</p>\n<h3>주요 특징</h3>\n<ul>\n<li><strong>선언형 처리</strong>: 무엇을 할지만 명시</li>\n<li><strong>지연 연산</strong>: 최종 연산이 호출될 때까지 중간 연산을 실행하지 않음</li>\n<li><strong>병렬 처리</strong>: 멀티코어를 활용한 병렬 처리 가능</li>\n</ul>\n<h2>Stream 생성</h2>\n<pre><code class=\"language-java\">// 컬렉션으로부터\nList&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);\nStream&lt;String&gt; stream = list.stream();\n\n// 배열로부터\nString[] array = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};\nStream&lt;String&gt; stream = Arrays.stream(array);\n\n// 직접 생성\nStream&lt;String&gt; stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);\n\n// 무한 스트림\nStream&lt;Integer&gt; infiniteStream = Stream.iterate(0, n -&gt; n + 2);\n</code></pre>\n<h2>중간 연산 (Intermediate Operations)</h2>\n<h3>filter() - 조건에 맞는 요소만 선택</h3>\n<pre><code class=\"language-java\">List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6);\nList&lt;Integer&gt; evenNumbers = numbers.stream()\n    .filter(n -&gt; n % 2 == 0)\n    .collect(Collectors.toList());\n// 결과: [2, 4, 6]\n</code></pre>\n<h3>map() - 요소를 변환</h3>\n<pre><code class=\"language-java\">List&lt;String&gt; names = Arrays.asList(&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;);\nList&lt;Integer&gt; lengths = names.stream()\n    .map(String::length)\n    .collect(Collectors.toList());\n// 결과: [5, 6, 6]\n</code></pre>\n<h3>sorted() - 정렬</h3>\n<pre><code class=\"language-java\">List&lt;String&gt; sorted = names.stream()\n    .sorted()\n    .collect(Collectors.toList());\n\n// 역순 정렬\nList&lt;String&gt; reverseSorted = names.stream()\n    .sorted(Comparator.reverseOrder())\n    .collect(Collectors.toList());\n</code></pre>\n<h3>distinct() - 중복 제거</h3>\n<pre><code class=\"language-java\">List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 2, 3, 3, 4);\nList&lt;Integer&gt; unique = numbers.stream()\n    .distinct()\n    .collect(Collectors.toList());\n// 결과: [1, 2, 3, 4]\n</code></pre>\n<h2>최종 연산 (Terminal Operations)</h2>\n<h3>collect() - 결과를 컬렉션으로 변환</h3>\n<pre><code class=\"language-java\">// List로 수집\nList&lt;String&gt; list = stream.collect(Collectors.toList());\n\n// Set으로 수집\nSet&lt;String&gt; set = stream.collect(Collectors.toSet());\n\n// Map으로 수집\nMap&lt;String, Integer&gt; map = names.stream()\n    .collect(Collectors.toMap(\n        name -&gt; name,\n        String::length\n    ));\n</code></pre>\n<h3>forEach() - 각 요소에 대해 작업 수행</h3>\n<pre><code class=\"language-java\">names.stream()\n    .forEach(System.out::println);\n</code></pre>\n<h3>reduce() - 요소를 하나씩 줄여가며 연산</h3>\n<pre><code class=\"language-java\">// 합계\nint sum = numbers.stream()\n    .reduce(0, (a, b) -&gt; a + b);\n\n// 곱셈\nint product = numbers.stream()\n    .reduce(1, (a, b) -&gt; a * b);\n</code></pre>\n<h3>count() - 요소 개수</h3>\n<pre><code class=\"language-java\">long count = stream.count();\n</code></pre>\n<h3>anyMatch(), allMatch(), noneMatch()</h3>\n<pre><code class=\"language-java\">boolean hasEven = numbers.stream()\n    .anyMatch(n -&gt; n % 2 == 0);\n\nboolean allPositive = numbers.stream()\n    .allMatch(n -&gt; n &gt; 0);\n\nboolean noneNegative = numbers.stream()\n    .noneMatch(n -&gt; n &lt; 0);\n</code></pre>\n<h2>실전 예제</h2>\n<h3>1. 사용자 필터링 및 변환</h3>\n<pre><code class=\"language-java\">class User {\n    String name;\n    int age;\n    String city;\n}\n\nList&lt;String&gt; adultNamesInSeoul = users.stream()\n    .filter(user -&gt; user.getAge() &gt;= 20)\n    .filter(user -&gt; &quot;Seoul&quot;.equals(user.getCity()))\n    .map(User::getName)\n    .collect(Collectors.toList());\n</code></pre>\n<h3>2. 그룹핑</h3>\n<pre><code class=\"language-java\">// 나이별로 그룹핑\nMap&lt;Integer, List&lt;User&gt;&gt; byAge = users.stream()\n    .collect(Collectors.groupingBy(User::getAge));\n\n// 도시별 사용자 수\nMap&lt;String, Long&gt; countByCity = users.stream()\n    .collect(Collectors.groupingBy(\n        User::getCity,\n        Collectors.counting()\n    ));\n</code></pre>\n<h3>3. 통계</h3>\n<pre><code class=\"language-java\">IntSummaryStatistics stats = numbers.stream()\n    .mapToInt(Integer::intValue)\n    .summaryStatistics();\n\nSystem.out.println(&quot;Count: &quot; + stats.getCount());\nSystem.out.println(&quot;Sum: &quot; + stats.getSum());\nSystem.out.println(&quot;Min: &quot; + stats.getMin());\nSystem.out.println(&quot;Max: &quot; + stats.getMax());\nSystem.out.println(&quot;Average: &quot; + stats.getAverage());\n</code></pre>\n<h2>병렬 스트림</h2>\n<pre><code class=\"language-java\">// 순차 스트림\nlong count = list.stream()\n    .filter(s -&gt; s.length() &gt; 5)\n    .count();\n\n// 병렬 스트림\nlong count = list.parallelStream()\n    .filter(s -&gt; s.length() &gt; 5)\n    .count();\n</code></pre>\n<p><strong>주의사항</strong>: 병렬 스트림은 항상 빠른 것은 아닙니다. 데이터 양이 적거나 연산이 간단한 경우 오히려 오버헤드가 발생할 수 있습니다.</p>\n<h2>성능 최적화 팁</h2>\n<ol>\n<li><strong>불필요한 박싱/언박싱 피하기</strong>: <code>IntStream</code>, <code>LongStream</code>, <code>DoubleStream</code> 사용</li>\n<li><strong>적절한 순서</strong>: <code>filter</code>를 먼저, <code>map</code>을 나중에</li>\n<li><strong>병렬 처리 신중하게</strong>: 데이터 양과 연산 복잡도 고려</li>\n</ol>\n<h2>결론</h2>\n<p>Stream API는 코드를 더 간결하고 읽기 쉽게 만들어줍니다. 함수형 프로그래밍 패러다임을 이해하고 적절히 활용하면 생산성이 크게 향상됩니다! 🚀</p>\n",
    "rawContent": "\n# Java Stream API 완벽 가이드\n\nJava 8부터 도입된 Stream API는 컬렉션 데이터를 함수형 스타일로 처리할 수 있게 해줍니다.\n\n## Stream이란?\n\nStream은 데이터의 흐름을 나타내는 객체로, 컬렉션의 요소를 하나씩 참조하여 람다식으로 처리할 수 있는 기능입니다.\n\n### 주요 특징\n\n- **선언형 처리**: 무엇을 할지만 명시\n- **지연 연산**: 최종 연산이 호출될 때까지 중간 연산을 실행하지 않음\n- **병렬 처리**: 멀티코어를 활용한 병렬 처리 가능\n\n## Stream 생성\n\n```java\n// 컬렉션으로부터\nList<String> list = Arrays.asList(\"a\", \"b\", \"c\");\nStream<String> stream = list.stream();\n\n// 배열로부터\nString[] array = {\"a\", \"b\", \"c\"};\nStream<String> stream = Arrays.stream(array);\n\n// 직접 생성\nStream<String> stream = Stream.of(\"a\", \"b\", \"c\");\n\n// 무한 스트림\nStream<Integer> infiniteStream = Stream.iterate(0, n -> n + 2);\n```\n\n## 중간 연산 (Intermediate Operations)\n\n### filter() - 조건에 맞는 요소만 선택\n\n```java\nList<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);\nList<Integer> evenNumbers = numbers.stream()\n    .filter(n -> n % 2 == 0)\n    .collect(Collectors.toList());\n// 결과: [2, 4, 6]\n```\n\n### map() - 요소를 변환\n\n```java\nList<String> names = Arrays.asList(\"apple\", \"banana\", \"cherry\");\nList<Integer> lengths = names.stream()\n    .map(String::length)\n    .collect(Collectors.toList());\n// 결과: [5, 6, 6]\n```\n\n### sorted() - 정렬\n\n```java\nList<String> sorted = names.stream()\n    .sorted()\n    .collect(Collectors.toList());\n\n// 역순 정렬\nList<String> reverseSorted = names.stream()\n    .sorted(Comparator.reverseOrder())\n    .collect(Collectors.toList());\n```\n\n### distinct() - 중복 제거\n\n```java\nList<Integer> numbers = Arrays.asList(1, 2, 2, 3, 3, 4);\nList<Integer> unique = numbers.stream()\n    .distinct()\n    .collect(Collectors.toList());\n// 결과: [1, 2, 3, 4]\n```\n\n## 최종 연산 (Terminal Operations)\n\n### collect() - 결과를 컬렉션으로 변환\n\n```java\n// List로 수집\nList<String> list = stream.collect(Collectors.toList());\n\n// Set으로 수집\nSet<String> set = stream.collect(Collectors.toSet());\n\n// Map으로 수집\nMap<String, Integer> map = names.stream()\n    .collect(Collectors.toMap(\n        name -> name,\n        String::length\n    ));\n```\n\n### forEach() - 각 요소에 대해 작업 수행\n\n```java\nnames.stream()\n    .forEach(System.out::println);\n```\n\n### reduce() - 요소를 하나씩 줄여가며 연산\n\n```java\n// 합계\nint sum = numbers.stream()\n    .reduce(0, (a, b) -> a + b);\n\n// 곱셈\nint product = numbers.stream()\n    .reduce(1, (a, b) -> a * b);\n```\n\n### count() - 요소 개수\n\n```java\nlong count = stream.count();\n```\n\n### anyMatch(), allMatch(), noneMatch()\n\n```java\nboolean hasEven = numbers.stream()\n    .anyMatch(n -> n % 2 == 0);\n\nboolean allPositive = numbers.stream()\n    .allMatch(n -> n > 0);\n\nboolean noneNegative = numbers.stream()\n    .noneMatch(n -> n < 0);\n```\n\n## 실전 예제\n\n### 1. 사용자 필터링 및 변환\n\n```java\nclass User {\n    String name;\n    int age;\n    String city;\n}\n\nList<String> adultNamesInSeoul = users.stream()\n    .filter(user -> user.getAge() >= 20)\n    .filter(user -> \"Seoul\".equals(user.getCity()))\n    .map(User::getName)\n    .collect(Collectors.toList());\n```\n\n### 2. 그룹핑\n\n```java\n// 나이별로 그룹핑\nMap<Integer, List<User>> byAge = users.stream()\n    .collect(Collectors.groupingBy(User::getAge));\n\n// 도시별 사용자 수\nMap<String, Long> countByCity = users.stream()\n    .collect(Collectors.groupingBy(\n        User::getCity,\n        Collectors.counting()\n    ));\n```\n\n### 3. 통계\n\n```java\nIntSummaryStatistics stats = numbers.stream()\n    .mapToInt(Integer::intValue)\n    .summaryStatistics();\n\nSystem.out.println(\"Count: \" + stats.getCount());\nSystem.out.println(\"Sum: \" + stats.getSum());\nSystem.out.println(\"Min: \" + stats.getMin());\nSystem.out.println(\"Max: \" + stats.getMax());\nSystem.out.println(\"Average: \" + stats.getAverage());\n```\n\n## 병렬 스트림\n\n```java\n// 순차 스트림\nlong count = list.stream()\n    .filter(s -> s.length() > 5)\n    .count();\n\n// 병렬 스트림\nlong count = list.parallelStream()\n    .filter(s -> s.length() > 5)\n    .count();\n```\n\n**주의사항**: 병렬 스트림은 항상 빠른 것은 아닙니다. 데이터 양이 적거나 연산이 간단한 경우 오히려 오버헤드가 발생할 수 있습니다.\n\n## 성능 최적화 팁\n\n1. **불필요한 박싱/언박싱 피하기**: `IntStream`, `LongStream`, `DoubleStream` 사용\n2. **적절한 순서**: `filter`를 먼저, `map`을 나중에\n3. **병렬 처리 신중하게**: 데이터 양과 연산 복잡도 고려\n\n## 결론\n\nStream API는 코드를 더 간결하고 읽기 쉽게 만들어줍니다. 함수형 프로그래밍 패러다임을 이해하고 적절히 활용하면 생산성이 크게 향상됩니다! 🚀\n\n"
  },
  {
    "id": "2025-10-01-welcome",
    "slug": "2025-10-01-welcome",
    "title": "블로그에 오신 것을 환영합니다!",
    "date": "2025-10-01",
    "category": "Life",
    "subcategory": null,
    "tags": [
      "블로그",
      "시작",
      "환영"
    ],
    "excerpt": "새로운 블로그를 시작합니다. 개발, 디자인, 그리고 일상에 대한 이야기를 공유할 예정입니다.",
    "author": "Geon Lee",
    "content": "<h1>블로그에 오신 것을 환영합니다! 👋</h1>\n<p>안녕하세요! 이 블로그의 첫 번째 포스트입니다.</p>\n<h2>블로그 소개</h2>\n<p>이 블로그에서는 다음과 같은 내용을 다룰 예정입니다:</p>\n<ul>\n<li>🚀 <strong>개발</strong>: 개발 언어와 프레임워크, CS등 개발에 대해 이해하고, 연구하는 개발 관련 글</li>\n<li>💡 <strong>일상</strong>: 개발자의 삶과 생각들</li>\n</ul>\n<h2>기술 스택</h2>\n<p>이 블로그는 다음 기술로 만들어졌습니다:</p>\n<ul>\n<li>React + TypeScript</li>\n<li>Vite</li>\n<li>Tailwind CSS</li>\n<li>shadcn/ui</li>\n<li>GitHub Pages</li>\n</ul>\n<h2>앞으로의 계획</h2>\n<p>앞으로 다양한 주제의 글을 꾸준히 올릴 예정입니다.<br>방문해주셔서 감사합니다! 🙏</p>\n",
    "rawContent": "\n# 블로그에 오신 것을 환영합니다! 👋\n\n안녕하세요! 이 블로그의 첫 번째 포스트입니다.\n\n## 블로그 소개\n\n이 블로그에서는 다음과 같은 내용을 다룰 예정입니다:\n\n- 🚀 **개발**: 개발 언어와 프레임워크, CS등 개발에 대해 이해하고, 연구하는 개발 관련 글\n- 💡 **일상**: 개발자의 삶과 생각들\n\n## 기술 스택\n\n이 블로그는 다음 기술로 만들어졌습니다:\n\n- React + TypeScript\n- Vite\n- Tailwind CSS\n- shadcn/ui\n- GitHub Pages\n\n## 앞으로의 계획\n\n앞으로 다양한 주제의 글을 꾸준히 올릴 예정입니다. \n방문해주셔서 감사합니다! 🙏\n\n"
  }
]